'''№ 12113 Новогодний вариант (Уровень: Базовый)
(М. Попков) У Санта-Клауса и его команды для упаковки подарков есть N кубических коробок двух цветов.
Самой привлекательной для детей считается упаковка подарка по принципу матрёшки – подарок упаковывается в одну из коробок,
та в свою очередь в другую коробку и т.д, при этом их цвета обязательно должны чередоваться.
Одну коробку можно поместить в другую, если длина её стороны хотя бы на 7 единиц меньше длины стороны другой коробки.
Коробка с нечетной длиной стороны - красная, с четной - синяя.
Определите наибольшее количество коробок, которое можно использовать для упаковки одного подарка,
и максимально возможную длину стороны самой маленькой коробки, где будет находиться подарок.
Размер подарка позволяет поместить его в самую маленькую коробку.

Входные данные

В первой строке входного файла находится число N – количество коробок у Санта-Клауса (натуральное число, не превышающее 10 000).
В следующих N строках находятся значения длин сторон коробок (все числа натуральные, не превышающие 10 000), каждое – в отдельной строке.

Запишите в ответе два целых числа: сначала наибольшее количество коробок,
которое можно использовать для упаковки одного подарка,
затем максимально возможную длину стороны самой маленькой коробки в таком наборе.

Типовой пример организации данных во входном файле

6
43
40
33
28
40
29

Пример входного файла приведён для шести коробок и случая,
когда минимальная допустимая разница между длинами сторон коробок,
подходящих для упаковки «матрёшкой», составляет 3 единицы.

При таких исходных данных условию задачи удовлетворяют наборы коробок с длинами сторон 29, 40 и 43 или 33, 40 и 43 или 28, 33, 40, 43 соответственно,
т.е. наибольшее количество коробок равно 4, а наибольшая длина стороны самой маленькой коробки равна 28.

Типовой пример имеет иллюстративный характер. Для выполнения задания используйте данные из прилагаемых файлов.'''

f = open('files/26_12113.txt')
n = int(f.readline())
sp = []

for i in f:
    sp.append([int(i), int(i) % 2])

sp = sorted(sp, reverse=True)
otvet = 0

for i in range(50):
    box_n = sp[i]
    count = 1
    for j in range(i, n):
        if box_n[0] - sp[j][0] >= 7:
            if box_n[1] != sp[j][1]:
                count += 1
                box_n = sp[j]
                min_b = sp[j][0]
    if count > otvet:
        otvet = count
        min_b = box_n[0]

print(otvet, min_b)

'''Этот код предназначен для решения задачи, связанной с чтением данных из файла и выполнением определенных вычислений.

1. Открывается файл 'files/26_12113.txt' и считывается первая строка, которая должна представлять собой целое число. Это число сохраняется в переменной `n`.

2. Создается пустой список `sp`, который будет использоваться для хранения пар чисел и их остатков от деления на 2.

3. Для каждой строки в файле, кроме первой, число преобразуется в целое число, и пара число-остаток от деления на 2 добавляется в список `sp`.

4. Список `sp` сортируется в порядке убывания, используя функцию `sorted` с параметром `reverse=True`.

5. Инициализируется переменная `otvet`, которая будет использоваться для хранения максимального количества подходящих пар.

6. Выполняется цикл по первым 50 элементам списка `sp`. Для каждого элемента выполняется вложенный цикл, который проверяет, можно ли выбрать следующую пару так, чтобы разница между числами была не менее 7 и чтобы числа имели разные остатки от деления на 2. Если это возможно, счетчик увеличивается на 1, а текущая пара становится новой базовой парой.

7. Если количество подходящих пар больше, чем `otvet`, `otvet` обновляется и сохраняется минимальное число из выбранных пар.

8. В конце программы выводится максимальное количество подходящих пар и минимальное число из выбранных пар.'''

# Открываем файл 'files/26_12113.txt' и считываем первую строку, которая должна быть числом
f = open('files/26_12113.txt')
n = int(f.readline())

# Создаем пустой список sp, который будет использоваться для хранения пар чисел и их остатков от деления на 2
sp = []

# Для каждой строки в файле, кроме первой, число преобразуется в целое число,
# и пара число-остаток от деления на 2 добавляется в список sp
for i in f:
    sp.append([int(i), int(i) % 2])

# Список sp сортируется в порядке убывания
sp = sorted(sp, reverse=True)

# Инициализируется переменная otvet, которая будет использоваться для хранения максимального количества подходящих пар
otvet = 0

# Выполняется цикл по первым 50 элементам списка sp
for i in range(50):
    box_n = sp[i]  # Текущая пара чисел
    count = 1  # Счетчик подходящих пар
    # Вложенный цикл, который проверяет, можно ли выбрать следующую пару так, чтобы разница между числами была не менее 7
    # и чтобы числа имели разные остатки от деления на 2
    for j in range(i, n):
        if box_n[0] - sp[j][0] >= 7:
            if box_n[1] != sp[j][1]:
                count += 1
                box_n = sp[j]
                min_b = sp[j][0]
    # Если количество подходящих пар больше, чем otvet, otvet обновляется и сохраняется минимальное число из выбранных пар
    if count > otvet:
        otvet = count
        min_b = box_n[0]

# В конце программы выводится максимальное количество подходящих пар и минимальное число из выбранных пар
print(otvet, min_b)

