"""with open('files/26.txt') as f:
    a = f.readlines()
s, d = map(int, a[0].split())
del a[0]
a = sorted(list(map(int, a)))  # сортировать, список, преобразовать в int

# enumerate() - обрабатывает и значение элемента, и его индекс
v = 0  # объем
for i, z in enumerate(a):
    if v + z > s:
        break
    v += z
print(i)  # 568

d = s - v  # 24 - остаток
b = [x for x in a if x - a[i-1] <= d]
print(max(b))  # 50"""

# №27883
"""Системный администратор раз в неделю создаёт архив пользовательских файлов. Однако объём
диска, куда он помещает архив, может быть меньше, чем суммарный объём архивируемых файлов.
Известно, какой объём занимает файл каждого пользователя.
По заданной информации об объёме файлов пользователей и свободном объёме на архивном
диске определите максимальное число пользователей, чьи файлы можно сохранить в архиве, а также
максимальный размер имеющегося файла, который может быть сохранён в архиве, при условии, что
сохранены файлы максимально возможного числа пользователей."""
"""with open('files/26_27883.txt') as f:
    a = f.readlines()
s, d = map(int, a[0].split())
del a[0]
a = sorted(list(map(int, a)))

v = 0
for i, n in enumerate(a):
    if v + n > s:
        break
    v += n
print(i)  # 149
d = s - v  # 0 - остаток
print(d)
b = [x for x in a if x - a[i - 1] <= d]
print(max(b))  # 7"""

# №36000
"""В текстовом файле записан набор натуральных чисел, не превышающих 10^9. Гарантируется, что
все числа различны. Необходимо определить, сколько в наборе таких пар чисел, что числа в паре
имеют разную чётность, а их сумма тоже присутствует в файле, и чему равна наибольшая из сумм
таких пар."""
"""with open('files/26_36000.txt') as f:
    v = f.readline()
    s = f.readlines()
s = list(map(int, s))
ns = set(s)
ans = []
for i in range(len(s) - 1):
    for j in range(i+1, len(s)):
        if (s[i] % 2 == 0 and s[j] % 2 != 0) or (s[i] % 2 != 0 and s[j] % 2 == 0):
            if (s[i] + s[j]) in ns:
                ans.append(s[i] + s[j])

print(len(ans), max(ans))  # 15 954387771"""

"""f = open('files/26_36000.txt')
k = f.readlines()
n = list(map(int, k))
m = 0
s = 0
c = 0
ns = set(n)
for i in range(1, len(n) - 1):
    for j in range(i + 1, len(n)):
        if (n[i] + n[j]) % 2 == 1:
            s = n[i] + n[j]
            if s in ns:
                c += 1
                if s > m:
                    m = s

print(c, m)  # 15 954387771"""

# ДЕМО 2024
"""with open('files/26_2024.txt') as f:
    n = int(f.readline())
    a = []
    for i in range(n):
        b, c = map(int, f.readline().split())
        a.append([b, c])

a.sort(key=lambda x: x[1])

s = [[a[0][0], a[0][1]]]

for start, end in a[1:]:
    if start >= s[-1][1]:
        s.append([start, end])

print(len(s))
print(s[-1][0] - s[-2][1])  # 32 15"""

# 29674
"""from math import ceil

with open('files/inf_22_10_20_26.txt') as f:
    n = int(f.readline())  # 1000
    data = [int(x) for x in f]

no_discount = []
discount = []
for i in range(len(data)):
    if data[i] < 50:
        no_discount.append(data[i])
    else:
        discount.append(data[i])

discount.sort()  # len = 964

mx = 0
for j in range(len(discount[:482])):
    mx = max(mx, discount[j])
    discount[j] = discount[j] * 0.75

print(ceil(sum(no_discount) + sum(discount)), ceil(mx))  # 469784 511"""

# shcolkovo
"""Задача 1 #63357
В лесничестве саженцы сосны высадили параллельными рядами, которые пронумерованы идущими подряд натуральными числами. 
Растения в каждом ряду пронумерованы натуральными числами начиная с единицы. По данным аэрофотосъёмки известно, 
в каких рядах и на каких местах растения не прижились. Найдите ряд с наибольшим номером, 
в котором есть ровно 11 идущих подряд свободных мест для посадки новых сосен, таких, 
что непосредственно слева и справа от них в том же ряду растут сосны. 
Гарантируется, что есть хотя бы один ряд, удовлетворяющий этому условию. 
В ответе запишите два целых числа через пробел: наибольший номер ряда и 
наименьший номер места для посадки из числа найденных в этом ряду подходящих последовательностей из 11 свободных мест.

Входные данные. В первой строке входного файла находится число N – количество прижившихся саженцев сосны 
(натуральное число, не превышающее 20 000). Каждая из следующих N строк содержит два натуральных числа, 
не превышающих 100 000: номер ряда и номер места в этом ряду, на котором растёт деревце.

Выходные данные. Два целых неотрицательных числа через пробел: 
наибольший номер ряда и наименьший номер места в выбранной последовательности из 11 мест, 
подходящих для посадки новых сосен."""

"""f = open('files/264__1vi92__4jqay.txt')
n = int(f.readline())

a = []  # список координат прижившихся саженцев
for i in range(n):
    x, y = [int(_) for _ in f.readline().split()]  # считывание текущей строки
    a.append([x, y])
a.sort()

ans = [0, 0]

for i in range(n - 1):  # проход по всем координатам саженцев
    # если ряд двух рядом стоящих в списке саженцев совпадает и при этом между ними есть 11 свободных мест
    if a[i][0] == a[i + 1][0] and a[i][1] + 12 == a[i + 1][1]:
        row = a[i][0]  # вычисляем ряд
        place = a[i][1] + 1  # вычисляем минимальное свободное место
        if row > ans[0]:
            ans[0] = row
            ans[1] = place
print(*ans)  # 59966 81345"""

"""Задача 17#63360
При проведении эксперимента заряженные частицы попадают на чувствительный экран, 
представляющий из себя матрицу размером 100 000 на 100 000 точек. 
При попадании очередной частицы на экран в файл записываются координаты чувствительного элемента: 
номер строки (целое число от 1 до 100 000) и номер позиции в строке (целое число от 1 до 100 000). 
Точка экрана, в которую попала хотя бы одна частица, считается светлой, точка, 
в которую ни одна частица не попала, – тёмной.

Вам нужно определить наибольшую длину цепочки в одной строке, в которой светлые точки идут подряд. 
Если таких строк несколько, укажите номер первой из подходящих строк.

Входные данные представлены в файле следующим образом. 
В первой строке входного файла записано целое число N – количество частиц, попавших на экран. 
В каждой из следующих N строк записаны по два числа, разделённые пробелом: номер строки и номер позиции в строке.

Запишите в ответе два числа через пробел: сначала номер строки, в которой находится эта цепочка 
(если таких строк несколько, запишите минимальный из их номеров), 
затем количество светлых точек в самой длинной цепочке из светлых точек."""

"""f = open('files/267__1vi96.txt')
n = int(f.readline())  # 114091
print(n)
a = []
for i in range(n):
    x, y = [int(a) for a in f.readline().split()]
    a.append([x, y])
a.sort()

num_s = 0
num_d = []
m_num_s = 0  # номер строки
m_num_d = []  # наибольшая цепочка
for i in range(n - 1):
    if a[i][0] == a[i + 1][0] and a[i][1] + 1 == a[i + 1][1] or a[i][1] == a[i + 1][1]:
        # проверяем, что следующая точка такая же или на  больше(по порядку)
        num_s = a[i][0]
        num_d.append(a[i + 1][1])
        if len(num_d) > len(m_num_d):  # если текущая длина строки больше максимальной
            m_num_s = num_s
            m_num_d = num_d
            print(m_num_s, m_num_d)
    else:  # если числа идут не по порядку, то обнуляем:
        num_s = 0
        num_d = []
print(m_num_s, m_num_d)  # 2786
print(len(m_num_d))  # 10"""
# #57344
"""#57344 Предприятие производит оптовую закупку некоторых изделий A и B, на которую выделена определённая сумма денег. 
У поставщика есть в наличии партии этих изделий различных модификаций по различной цене. 
На выделенные деньги необходимо приобрести как можно больше изделий A независимо от модификации. 
Если у поставщика закончатся изделия A, то на оставшиеся деньги необходимо приобрести как можно больше изделий B. 
Известны выделенная для закупки сумма, а также количество и цена различных модификаций данных изделий у поставщика. 
Необходимо определить, сколько будет закуплено изделий B и на какую сумму.
Входные данные.
Первая строка входного файла 26_5.txt содержит два целых числа: 
N — общее количество партий изделий у поставщика и M — сумма выделенных на закупку денег (в рублях). 
Каждая из следующих N строк описывает одну партию и содержит два целых числа 
(цена одного изделия в рублях и количество изделий в партии) и один символ (латинская буква A или B), 
определяющий тип изделия. Все данные в строках входного файла отделены одним пробелом.
В ответе запишите два целых числа без пробелов и разделителей: сначала количество закупленных изделий типа В, 
затем сумму, которую потратили на закупку изделий типа В.
Пример входного файла:
4 1000
30 8 A
50 12 B
40 14 A
30 60 B
В данном случае сначала нужно купить изделия A: 8 изделий по 30 рублей и 14 изделий по 40 рублей. 
На это будет потрачено 800 рублей. На оставшиеся 200 рублей можно купить 6 изделий B по 30 рублей. 
Таким образом, всего будет куплено 6 изделий В на сумма 180р. В ответе надо записать числа 6 и 180."""
# DeepSeek
"""f = open('files/Задание_26__tsb8.txt')
n, m = map(int, f.readline().split())  # Чтение N и M
data = []
for i in range(n):
    cost, count, typ = f.readline().split()
    data.append([int(cost), int(count), str(typ)])

# Разделяем изделия A и B
a_items = [item for item in data if item[2] == 'A']
b_items = [item for item in data if item[2] == 'B']

# Сортируем изделия A по цене (от дешевых к дорогим)
a_items.sort(key=lambda x: x[0])

# Сортируем изделия B по цене (от дешевых к дорогим)
b_items.sort(key=lambda x: x[0])

# Покупаем сначала все изделия A
total_cost = 0
for item in a_items:
    cost, count, typ = item
    # Покупаем столько изделий, сколько возможно
    for _ in range(count):
        if total_cost + cost <= m:
            total_cost += cost
        else:
            break

# Покупаем изделия B на оставшиеся деньги
b_count = 0
b_total_cost = 0
for item in b_items:
    cost, count, typ = item
    # Покупаем столько изделий, сколько возможно
    for _ in range(count):
        if total_cost + cost <= m:
            total_cost += cost
            b_count += 1
            b_total_cost += cost
        else:
            break

print(b_count, b_total_cost)  #5101 854276"""

# Hometask 02.02
# 1
# Не решено
"""
Задача 1 #49390
Для перевозки партии грузов различной массы выделен грузовик, 
но его грузоподъёмность ограничена, поэтому перевезти сразу все грузы не удастся. 
Грузы массой от 180 до 200 кг грузят в первую очередь, выбирая грузы по убыванию массы, начиная с самого тяжёлого. 
На оставшееся после этого место стараются взять как можно большее количество грузов. 
Если это можно сделать несколькими способами, выбирают тот способ, 
при котором самый большой из выбранных грузов имеет наибольшую массу. 
Если и при этом условии возможно несколько вариантов, выбирается тот, 
при котором наибольшую массу имеет второй по величине груз, и т.д. 
Известны количество грузов, масса каждого из них и грузоподъёмность грузовика. 
Необходимо определить количество и общую массу грузов, которые будут вывезены при погрузке по вышеописанным правилам. 
Входные данные представлены в файле 26.txt следующим образом. 
В первой строке входного файла записаны два целых числа: 
N – общее количество грузов и M – грузоподъёмность грузовика в кг. 
Каждая из следующих N   строк содержит одно целое число – массу груза в кг. 
В ответе запишите два целых числа без пробела: сначала максимально возможное количество грузов, затем их общую массу.
Пример организации исходных данных во входном файле:
6 700
100
185
120
160
140
300
В данном случае сначала нужно взять груз массой 185 кг. 
Остается 515 кг. После этого можно вывезти ещё максимум 3 груза. 
Это можно сделать четырьмя способами: 100 + 120 + 140, 100 + 140 + 160, 100 + 120 + 160, 120 + 140 + 160. 
Выбираем способ, при котором вывозится груз наибольшей возможной массы. 
Таких способов три: 100 + 120 + 160, 100 + 140 + 160, 120 + 140 + 160. 
Из этих способов выбираем те, при которых больше масса второго по величине груза, 
то есть 100 + 140 + 160 и 120 + 140 + 160. 
Их них нужно выбрать вариант 120 + 140 + 160, так как в этом случае третий по величине груз наиболее тяжёлый. 
Всего получается 4 груза общей массой 605 кг."""
"""# Открываем файл для чтения
file = open("26.txt")

# Считываем первую строку файла и извлекаем количество грузов (n) и грузоподъёмность (m)
n, m = map(int, file.readline().split())

# Создаем пустой список для хранения масс грузов
array = []

# Читаем оставшиеся строки файла и добавляем массы грузов в массив
for line in file:
    array.append(int(line.strip()))  # Преобразуем каждую строку в целое число и добавляем в массив

# Сортируем массив по возрастанию массы грузов
array = sorted(array)

# Инициализируем переменные
i = 0  # Индекс для прохода по массиву
current_sum = 0  # Текущая масса выбранных грузов
last_elem = 0  # Масса последнего добавленного груза
ind_last = 0  # Индекс последнего добавленного груза в первой итерации
count = 0  # Количество выбранных грузов

# Первая часть: выбираем грузы весом от 180 до 200 кг
while i < len(array) and array[i] <= 200:
    if array[i] >= 180 and current_sum + array[i] <= m:
        current_sum += array[i]  # Добавляем массу груза к текущей сумме
        last_elem = array[i]  # Обновляем массу последнего добавленного груза
        count += 1  # Увеличиваем счетчик выбранных грузов
    else:
        ind_last = i  # Запоминаем индекс, если не удалось добавить груз
    i += 1  # Переходим к следующему грузу

# Вторая часть: выбираем грузы с меньшей массой до индекса ind_last
for j in range(ind_last):
    if current_sum + array[j] <= m:
        current_sum += array[j]  # Добавляем массу груза к текущей сумме
        last_elem = array[j]  # Обновляем массу последнего добавленного груза
        count += 1  # Увеличиваем счетчик выбранных грузов

# Третья часть: выбираем грузы с большей массой, начиная с индекса i
for j in range(i, len(array)):

    if current_sum + array[j] <= m:
        current_sum += array[j]  # Добавляем массу груза к текущей сумме
        last_elem = array[j]  # Обновляем массу последнего добавленного груза
        count += 1  # Увеличиваем счетчик выбранных грузов

# Вычисляем оставшееся место в грузовике
free_space = m - current_sum + last_elem

# Четвертая часть: ищем максимальный элемент, который можно добавить без превышения свободного места
for i in range(len(array) - 1, -1, -1):
    if array[i] <= free_space:  # Проверяем, помещается ли груз в оставшееся место
        current_sum += array[i] - last_elem  # Обновляем сумму, заменяя последний добавленный груз
        break  # Выходим из цикла после добавления

# Выводим результаты: количество выбранных грузов и их общую массу
print(count, current_sum)  # 118 10000"""

# 2
"""Задача 1 #25597
Задание выполняется с использованием прилагаемых файлов
Предприятие производит оптовую закупку некоторых изделий A и B, на которую выделена определённая сумма денег. 
У поставщика есть в наличии партии этих изделий различных модификаций по различной цене. 
На выделенные деньги необходимо приобрести как можно больше изделий A независимо от модификации. 
Если у поставщика закончатся изделия A, то на оставшиеся деньги необходимо приобрести как можно больше изделий B. 
Предприятие хочет закупить как можно больше деталей, 
но если при одинаковом количестваве деталей можно получить разную цену, 
то предприятие хочет оставить как можно больше денег себе.
Известны выделенная для закупки сумма, а также количество и цена различных модификаций данных изделий у поставщика. 
Необходимо определить, сколько будет закуплено изделий B и какая сумма останется неиспользованной.
Входные данные
Первая строка входного файла содержит два целых числа: 
N – общее количество партий изделий у поставщика и M – сумма выделенных на закупку денег (в рублях). 
Каждая из следующих N строк описывает одну партию и содержит два целых числа 
(цена одного изделия в рублях и количество изделий в партии) и один символ (латинская буква A или B), 
определяющий тип изделия. Все данные в строках входного файла отделены одним пробелом.
В ответе запишите два целых числа через пробел: сначала количество закупленных изделий типа B, 
затем оставшуюся неиспользованной сумму денег.
Пример входного файла
4 1000
30 8 A
50 12 B
40 14 A
30 60 B
В данном случае сначала нужно купить изделия A: 8 изделий по 30 рублей и 14 изделий по 40 рублей. 
На это будет потрачено 800 рублей. На оставшиеся 200 рублей можно купить 6 изделий B по 30 рублей. 
Таким образом, всего будет куплено 6 изделий B и останется 20 рублей. В ответе надо записать числа 6 и 20."""
"""f = open('files/Задание_26__tsb8.txt')
n, m = map(int, f.readline().split())  # 500 4000000
data = []
for i in range(n):
    cost, count, typ = f.readline().split()
    data.append([int(cost), int(count), str(typ)])
data.sort(key=lambda x: (x[2], x[0]))

buy = []
buy_b_count = 0
buy_b = []
f = False
for i in range(len(data)):
    if f:
        break
    for count in range(data[i][1]):
        if sum(buy) + data[i][0] <= m:
            buy.append(data[i][0])
            if data[i][2] == 'B':
                buy_b_count += 1
        else:
            print(buy_b_count, m - sum(buy))  # 5895 227
            f = True
            break"""

# 3 - не решено
# #86441
"""#86441 На производстве штучных изделий N деталей должны быть отшлифованы и окрашены. 
Для каждой детали известно время её шлифовки и время окрашивания. 
Детали пронумерованы начиная с единицы. Параллельная обработка деталей не предусмотрена. 
На ленте транспортёра имеется N мест для каждой из N деталей. 
На ленте транспортёра детали располагают по следующему алгоритму:
— все 2N чисел, обозначающих время окрашивания и шлифовки для N деталей, упорядочивают по возрастанию;
— если минимальное число в этом упорядоченном списке — это время шлифовки конкретной детали, 
то деталь размещают на ленте транспортёра на первое свободное место от её начала;
— если минимальное число — это время окрашивания, 
то деталь размещают на первое свободное место от конца ленты транспортёра.
— если число обозначает время окрашивания или шлифовки уже рассмотренной детали, то его не принимают во внимание.
Этот алгоритм применяется последовательно для размещения всех N деталей. Определите номер предпоследней детали, 
для которой будет определено её место на ленте транспортёра, и количество деталей, которые будут покрашены до неё.
Входные данные:
В первой строке входного файла находится натуральное число N (N < 1000) – количество деталей. 
Следующие N строк содержат пары чисел, обозначающих соответственно время шлифовки и 
время окрашивания конкретной детали (все числа натуральные, различные).
Запишите в ответе два натуральных числа через пробел: сначала номер предпоследней детали, 
для которой будет определено её место на ленте транспортёра, 
затем количество деталей, которые будут покрашены до неё."""
# Valeria 07.02
"""file = open('files/26_1M__3whph.txt')
k = int(file.readline())  # 997 # кол-во деталей
array_details = []
for i in range(k):
    detail = list(map(int, file.readline().split()))
    if detail[0] > detail[1]:
        array_details.append((detail[1], 'paint', i + 1))
    else:
        array_details.append((detail[0], 'grinding', i + 1))
array_details.sort()
lenta = [0] * k
det = []  # размещенные детали
for detail in array_details:
    if detail[1] == 'grinding':
        for i in range(len(lenta)):
            if lenta[i] == 0:
                lenta[i] = 1
                det.append(detail)
                break
    else:
        for i in range(len(lenta) - 1, -1, -1):
            if lenta[i] == 0:
                lenta[i] = 1
                det.append(detail)
                break
print(det[-2][2], len([x for x in det[:-2] if x[1] == 'paint']))  # 798 508"""

# shkolkovo
"""file = open('26_9793.txt')
count_details = int(file.readline())
array_details = []  # список, в котором у нас будут все детали файла
for i in range(count_details):
    detail = list(map(int, file.readline().split()))
    if detail[0] > detail[1]:  # если второе число меньше первого
        array_details.append((detail[1], 'paint', i + 1))  # то добавляем второе число, указываем,
        # что эту деталь отправим на покраску и передаём её номер
    else:  # в ином случае
        array_details.append((detail[0], 'grind', i + 1))  # тогда добавляем первое число, указываем,
        # что эту деталь отправим на шлифовку и передаём её номер
array_details.sort()
lenta = [0] * count_details  # симулируем ленту транспортёра
details = []  # список, в котором у нас будут детали, которые мы положили на ленту
for detail in array_details:  # проход по всевозможным деталям файла
    if detail[1] == 'grind':  # если эту деталь нужно отправить на шлифовку
        for i in range(len(lenta)):  # то делаем перебор с начала ленты
            if lenta[i] == 0:  # если эта ячейка свободна
                lenta[i] = 1  # указываем, что она занята
                details.append(detail)
                break  # сброс цикла для того, чтобы перейти к следующей детали
    else:  # в ином случае
        for i in range(len(lenta) - 1, -1, -1):  # перебор с конца ленты
            if lenta[i] == 0:  # если эта ячейка свободна
                lenta[i] = 1  # указываем, что она занята
                details.append(detail)
                break  # сброс цикла для того, чтобы перейти к следующей детали
# выводим номер, предпоследней детали, а также количество покрашенных деталей до этой детали
print(details[-2][2], len([x for x in details[:-2] if x[1] == 'paint']))  # 798 508"""

# 4
"""Задача 4#18208
Системный администратор раз в неделю создаёт архив пользовательских файлов. 
Однако объём диска, куда он помещает архив, может быть меньше, чем суммарный объём архивируемых файлов. 
Известно, какой объём занимает файл каждого пользователя.
По заданной информации об объёме файлов пользователей и 
свободном объёме на архивном диске определите максимальное число пользователей, 
чьи файлы можно сохранить в архиве, а также максимальный размер имеющегося файла, 
который может быть сохранён в архиве, при условии, что сохранены файлы максимально возможного числа пользователей.
Входные данные
В первой строке входного файла находятся два числа: 
S   — размер свободного места на диске (натуральное число, не превышающее 10 000) и 
N   — количество пользователей (натуральное число, не превышающее 1000). 
В следующих N строках находятся значения объёмов файлов каждого пользователя 
(все числа натуральные, не превышающие 100), каждое в отдельной строке.
Запишите в ответе два числа через пробел: сначала наибольшее число пользователей, 
чьи файлы могут быть помещены в архив, затем максимальный размер имеющегося файла, 
который может быть сохранён в архиве, при условии, что сохранены файлы максимально возможного числа пользователей."""

"""f = open('files/Задание_26__shd2.txt')
s, n = map(int, f.readline().split())  # 1987 4625
data = []
for i in range(n):
    data.append(int(f.readline()))
data.sort()

achive = []
i = 0
for i in range(n):
    if sum(achive) + data[i] < s:
        achive.append(data[i])
    else:
        extra = s - sum(achive)  # 8
        break

print(data)
print(achive)
mx = [x+extra for x in achive if x <= extra + achive[-1]]
print(len(achive), max(mx))  # 397 17"""
# shkolkovo
"""file = open("Задание 26.txt", "r", encoding="UTF-8")
lines = file.readlines()

s, n = map(int, lines[0].split())
array = list(map(int, lines[1:]))
array = sorted(array)

users_count = 0
maximum_file = 0
current_summ = 0
i = 0
while i < n:
    if current_summ + array[i] > s:
        break
    current_summ += array[i]
    i += 1

users_count = i
current_summ -= array[i - 1]

while i < n:
    if current_summ + array[i] > s:
        break
    i += 1
current_summ += array[i - 1]
maximum_file = array[i - 1]

print(users_count, maximum_file)  # 397 17"""

# 86442
"""На производстве штучных изделий N деталей должны быть отшлифованы и окрашены. 
Для каждой детали известно время её шлифовки и время окрашивания. Детали пронумерованы начиная с единицы. 
Параллельная обработка деталей не предусмотрена. На ленте транспортёра имеется N мест для каждой из N деталей. 
На ленте транспортёра детали располагают по следующему алгоритму:
— все 2N чисел, обозначающих время окрашивания и шлифовки для N деталей, упорядочивают по возрастанию;
— если минимальное число в этом упорядоченном списке — это время шлифовки конкретной детали, 
то деталь размещают на ленте транспортёра на первое свободное место от её начала;
— если минимальное число — это время окрашивания, 
то деталь размещают на первое свободное место от конца ленты транспортёра.
- из-за низкокачественных,безответственных сотрудников для каждой 5 детали определяется куда отправится деталь 
не по минимальному числу, а по максимальному.
— если число обозначает время окрашивания или шлифовки уже рассмотренной детали, то его не принимают во внимание.
Этот алгоритм применяется последовательно для размещения всех N деталей. 
Определите номер последней детали, отправленной на покраску, 
для которой будет определено её место на ленте транспортёра, затем количество деталей, назначенных на отшлифовку, 
расположенных на второй половине ленты.
Входные данные:
В первой строке входного файла находится натуральное число N (N < 1000) – количество деталей. 
Следующие N строк содержат пары чисел, обозначающих соответственно время шлифовки и 
время окрашивания конкретной детали (все числа натуральные, различные).
Запишите в ответе два натуральных числа через пробел: сначала номер последней детали, 
отправленной на покраску, для которой будет определено её место на ленте транспортёра, 
затем количество деталей, назначенных на отшлифовку, расположенных на второй половине ленты."""

"""file = open('files/26_4M__3whpp.txt')
k = int(file.readline())  # 997
array_details = []
for i in range(k):
    detail = list(map(int, file.readline().split()))
    if (i + 1) % 5 == 0:
        if detail[0] > detail[1]:
            array_details.append((detail[0], 'grinding', i + 1))
        else:
            array_details.append((detail[1], 'paint', i + 1))
    else:
        if detail[0] > detail[1]:
            array_details.append((detail[1], 'paint', i + 1))
        else:
            array_details.append((detail[0], 'grinding', i + 1))
array_details.sort()
det = []
lenta = [0] * k
for detail in array_details:
    if detail[1] == 'grinding':
        for i in range(len(lenta)):
            if lenta[i] == 0:
                lenta[i] = detail
                det.append(detail)
                break
    else:
        for i in range(len(lenta) - 1, -1, -1):
            if lenta[i] == 0:
                lenta[i] = detail
                det.append(detail)
                break

s = lenta[k//2:]

print([x[2] for x in det if x[1] == 'paint'][-1])  # 895
print(len([x for x in s if x[1] == 'grinding']))  # 18"""

# № 1
"""Запишите в ответе два натуральных числа через пробел: сначала количество деталей, 
которые будут отшлифованы, затем номер последней обработанной детали."""
"""f = open('files/26_1__3whs4.txt')
c = int(f.readline())  # 1000
array_details = []
for i in range(c):
    detail = list(map(int, f.readline().split()))  # шлифовка, окраска
    if detail[0] < detail[1]:
        array_details.append((detail[0], 'grinding', i + 1))
    else:
        array_details.append((detail[1], 'paint', i + 1))
array_details.sort()
details = []
lenta = [0] * c
for detail in array_details:
    if detail[1] == 'grinding':
        for i in range(len(lenta)):
            if lenta[i] == 0:
                lenta[i] = detail
                details.append(detail)
                break
    else:
        for i in range(len(lenta) - 1, -1, -1):
            if lenta[i] == 0:
                lenta[i] = detail
                details.append(detail)
                break
print(sum(1 for x in details if x[1] == 'grinding'))  # 484
print(details[-1][2])  # 544"""

# № 2
"""Запишите в ответе два натуральных числа через пробел: сначала время обработки детали, 
которая в итоге будет стоять на ленте транспортера на 168 месте, а затем суммарное время окрашивания деталей."""
"""f = open('files/26_3__3whrj.txt')
c = int(f.readline())  # 940
array_details = []
for i in range(c):
    detail = list(map(int, f.readline().split()))  # grinding, painting
    if detail[0] > detail[1]:
        array_details.append((detail[0], 'grinding', i+1))
    else:
        array_details.append((detail[1], 'painting', i+1))
array_details.sort(reverse=True)

lenta = [0] * c
for detail in array_details:
    if detail[1] == 'grinding':
        for i in range(len(lenta)):
            if lenta[i] == 0:
                lenta[i] = list(detail)
                break
    else:
        for i in range(len(lenta) - 1, -1, -1):
            if lenta[i] == 0:
                lenta[i] = list(detail)
                break

print(lenta[168-1][0])  # 1475
print(sum(x[0] for x in lenta if x[1] == 'painting'))  # 616262"""

# № 3
"""f = open('files/26_12__491va.txt')
c = int(f.readline())  # 900
array_details = []
for i in range(c):
    detail = list(map(int, f.readline().split()))
    if detail[1] > detail[0]:
        array_details.append((detail[1], 'painting', i))
    else:
        array_details.append((detail[0], 'grinding', i))
array_details.sort(reverse=True)  # т.к. максимальное

lenta = [0] * c
for detail in array_details:
    if detail[1] == 'painting':
        for i in range(len(lenta)):
            if lenta[i] == 0:
                lenta[i] = detail
                break
    else:
        for i in range(len(lenta) - 1, -1, -1):
            if lenta[i] == 0:
                lenta[i] = detail
                break
print(len([x for x in lenta if x[1] == 'painting']))  # 451
print([x[2] for x in lenta if x[1] == 'grinding'][-1])  # 646"""

# 29461
"""file = open('files/Задание_26__rg3w.txt')
lines = file.readlines()
n = int(lines[0])
array = list(map(int, lines[1:]))
array = sorted(array)

i = 0
tek = 0
while array[i] <= 130:
    tek += array[i]
    i += 1
t = i + (n - i) // 2 + (n % 2)
t = 4815 + (9300 - 4815) // 2 + (9300 % 2)

ans = tek + sum(array[t:]) + sum(array[i:t]) // 2 + sum(array[i:t]) % 2

print(ans, array[t - 1])"""

# 30259
"""file = open('files/4__tdop.txt')
lines = file.readlines()
n = int(lines[0])
array = list(map(int, lines[1:]))
array = sorted(array)

i = 0
s = 0
m = 0
while array[i] <= 200:
    s += array[i]
    i += 1

t = (n - i) // 2
while t > 0:
    s += array[i] * 0.7
    m = array[i]
    i += 1
    t -= 1

if (s + sum(array[i:])) % 1 != 0:
    print(int(s + sum(array[i:])) + 1, m)
else:
    print(int(s + sum((array[i:]))), m)"""

