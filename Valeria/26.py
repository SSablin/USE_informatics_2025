"""with open('files/26.txt') as f:
    a = f.readlines()
s, d = map(int, a[0].split())
del a[0]
a = sorted(list(map(int, a)))  # сортировать, список, преобразовать в int

# enumerate() - обрабатывает и значение элемента, и его индекс
v = 0  # объем
for i, z in enumerate(a):
    if v + z > s:
        break
    v += z
print(i)  # 568

d = s - v  # 24 - остаток
b = [x for x in a if x - a[i-1] <= d]
print(max(b))  # 50"""

# №27883
"""Системный администратор раз в неделю создаёт архив пользовательских файлов. Однако объём
диска, куда он помещает архив, может быть меньше, чем суммарный объём архивируемых файлов.
Известно, какой объём занимает файл каждого пользователя.
По заданной информации об объёме файлов пользователей и свободном объёме на архивном
диске определите максимальное число пользователей, чьи файлы можно сохранить в архиве, а также
максимальный размер имеющегося файла, который может быть сохранён в архиве, при условии, что
сохранены файлы максимально возможного числа пользователей."""
"""with open('files/26_27883.txt') as f:
    a = f.readlines()
s, d = map(int, a[0].split())
del a[0]
a = sorted(list(map(int, a)))

v = 0
for i, n in enumerate(a):
    if v + n > s:
        break
    v += n
print(i)  # 149
d = s - v  # 0 - остаток
print(d)
b = [x for x in a if x - a[i - 1] <= d]
print(max(b))  # 7"""

# №36000
"""В текстовом файле записан набор натуральных чисел, не превышающих 10^9. Гарантируется, что
все числа различны. Необходимо определить, сколько в наборе таких пар чисел, что числа в паре
имеют разную чётность, а их сумма тоже присутствует в файле, и чему равна наибольшая из сумм
таких пар."""
"""with open('files/26_36000.txt') as f:
    v = f.readline()
    s = f.readlines()
s = list(map(int, s))
ns = set(s)
ans = []
for i in range(len(s) - 1):
    for j in range(i+1, len(s)):
        if (s[i] % 2 == 0 and s[j] % 2 != 0) or (s[i] % 2 != 0 and s[j] % 2 == 0):
            if (s[i] + s[j]) in ns:
                ans.append(s[i] + s[j])

print(len(ans), max(ans))  # 15 954387771"""

"""f = open('files/26_36000.txt')
k = f.readlines()
n = list(map(int, k))
m = 0
s = 0
c = 0
ns = set(n)
for i in range(1, len(n) - 1):
    for j in range(i + 1, len(n)):
        if (n[i] + n[j]) % 2 == 1:
            s = n[i] + n[j]
            if s in ns:
                c += 1
                if s > m:
                    m = s

print(c, m)  # 15 954387771"""

# ДЕМО 2024
"""with open('files/26_2024.txt') as f:
    n = int(f.readline())
    a = []
    for i in range(n):
        b, c = map(int, f.readline().split())
        a.append([b, c])

a.sort(key=lambda x: x[1])

s = [[a[0][0], a[0][1]]]

for start, end in a[1:]:
    if start >= s[-1][1]:
        s.append([start, end])

print(len(s))
print(s[-1][0] - s[-2][1])  # 32 15"""

# 29674
"""from math import ceil

with open('files/inf_22_10_20_26.txt') as f:
    n = int(f.readline())  # 1000
    data = [int(x) for x in f]

no_discount = []
discount = []
for i in range(len(data)):
    if data[i] < 50:
        no_discount.append(data[i])
    else:
        discount.append(data[i])

discount.sort()  # len = 964

mx = 0
for j in range(len(discount[:482])):
    mx = max(mx, discount[j])
    discount[j] = discount[j] * 0.75

print(ceil(sum(no_discount) + sum(discount)), ceil(mx))  # 469784 511"""

# shcolkovo
"""Задача 1 #63357
В лесничестве саженцы сосны высадили параллельными рядами, которые пронумерованы идущими подряд натуральными числами. 
Растения в каждом ряду пронумерованы натуральными числами начиная с единицы. По данным аэрофотосъёмки известно, 
в каких рядах и на каких местах растения не прижились. Найдите ряд с наибольшим номером, 
в котором есть ровно 11 идущих подряд свободных мест для посадки новых сосен, таких, 
что непосредственно слева и справа от них в том же ряду растут сосны. 
Гарантируется, что есть хотя бы один ряд, удовлетворяющий этому условию. 
В ответе запишите два целых числа через пробел: наибольший номер ряда и 
наименьший номер места для посадки из числа найденных в этом ряду подходящих последовательностей из 11 свободных мест.

Входные данные. В первой строке входного файла находится число N – количество прижившихся саженцев сосны 
(натуральное число, не превышающее 20 000). Каждая из следующих N строк содержит два натуральных числа, 
не превышающих 100 000: номер ряда и номер места в этом ряду, на котором растёт деревце.

Выходные данные. Два целых неотрицательных числа через пробел: 
наибольший номер ряда и наименьший номер места в выбранной последовательности из 11 мест, 
подходящих для посадки новых сосен."""

"""f = open('files/264__1vi92__4jqay.txt')
n = int(f.readline())

a = []  # список координат прижившихся саженцев
for i in range(n):
    x, y = [int(_) for _ in f.readline().split()]  # считывание текущей строки
    a.append([x, y])
a.sort()

ans = [0, 0]

for i in range(n - 1):  # проход по всем координатам саженцев
    # если ряд двух рядом стоящих в списке саженцев совпадает и при этом между ними есть 11 свободных мест
    if a[i][0] == a[i + 1][0] and a[i][1] + 12 == a[i + 1][1]:
        row = a[i][0]  # вычисляем ряд
        place = a[i][1] + 1  # вычисляем минимальное свободное место
        if row > ans[0]:
            ans[0] = row
            ans[1] = place
print(*ans)  # 59966 81345"""

"""Задача 17#63360
При проведении эксперимента заряженные частицы попадают на чувствительный экран, 
представляющий из себя матрицу размером 100 000 на 100 000 точек. 
При попадании очередной частицы на экран в файл записываются координаты чувствительного элемента: 
номер строки (целое число от 1 до 100 000) и номер позиции в строке (целое число от 1 до 100 000). 
Точка экрана, в которую попала хотя бы одна частица, считается светлой, точка, 
в которую ни одна частица не попала, – тёмной.

Вам нужно определить наибольшую длину цепочки в одной строке, в которой светлые точки идут подряд. 
Если таких строк несколько, укажите номер первой из подходящих строк.

Входные данные представлены в файле следующим образом. 
В первой строке входного файла записано целое число N – количество частиц, попавших на экран. 
В каждой из следующих N строк записаны по два числа, разделённые пробелом: номер строки и номер позиции в строке.

Запишите в ответе два числа через пробел: сначала номер строки, в которой находится эта цепочка 
(если таких строк несколько, запишите минимальный из их номеров), 
затем количество светлых точек в самой длинной цепочке из светлых точек."""

"""f = open('files/267__1vi96.txt')
n = int(f.readline())  # 114091
print(n)
a = []
for i in range(n):
    x, y = [int(a) for a in f.readline().split()]
    a.append([x, y])
a.sort()

num_s = 0
num_d = []
m_num_s = 0  # номер строки
m_num_d = []  # наибольшая цепочка
for i in range(n - 1):
    if a[i][0] == a[i + 1][0] and a[i][1] + 1 == a[i + 1][1] or a[i][1] == a[i + 1][1]:
        # проверяем, что следующая точка такая же или на  больше(по порядку)
        num_s = a[i][0]
        num_d.append(a[i + 1][1])
        if len(num_d) > len(m_num_d):  # если текущая длина строки больше максимальной
            m_num_s = num_s
            m_num_d = num_d
            print(m_num_s, m_num_d)
    else:  # если числа идут не по порядку, то обнуляем:
        num_s = 0
        num_d = []
print(m_num_s, m_num_d)  # 2786
print(len(m_num_d))  # 10"""
# #57344
"""#57344 Предприятие производит оптовую закупку некоторых изделий A и B, на которую выделена определённая сумма денег. 
У поставщика есть в наличии партии этих изделий различных модификаций по различной цене. 
На выделенные деньги необходимо приобрести как можно больше изделий A независимо от модификации. 
Если у поставщика закончатся изделия A, то на оставшиеся деньги необходимо приобрести как можно больше изделий B. 
Известны выделенная для закупки сумма, а также количество и цена различных модификаций данных изделий у поставщика. 
Необходимо определить, сколько будет закуплено изделий B и на какую сумму.
Входные данные.
Первая строка входного файла 26_5.txt содержит два целых числа: 
N — общее количество партий изделий у поставщика и M — сумма выделенных на закупку денег (в рублях). 
Каждая из следующих N строк описывает одну партию и содержит два целых числа 
(цена одного изделия в рублях и количество изделий в партии) и один символ (латинская буква A или B), 
определяющий тип изделия. Все данные в строках входного файла отделены одним пробелом.
В ответе запишите два целых числа без пробелов и разделителей: сначала количество закупленных изделий типа В, 
затем сумму, которую потратили на закупку изделий типа В.
Пример входного файла:
4 1000
30 8 A
50 12 B
40 14 A
30 60 B
В данном случае сначала нужно купить изделия A: 8 изделий по 30 рублей и 14 изделий по 40 рублей. 
На это будет потрачено 800 рублей. На оставшиеся 200 рублей можно купить 6 изделий B по 30 рублей. 
Таким образом, всего будет куплено 6 изделий В на сумма 180р. В ответе надо записать числа 6 и 180."""
# DeepSeek
"""f = open('files/Задание_26__tsb8.txt')
n, m = map(int, f.readline().split())  # Чтение N и M
data = []
for i in range(n):
    cost, count, typ = f.readline().split()
    data.append([int(cost), int(count), str(typ)])

# Разделяем изделия A и B
a_items = [item for item in data if item[2] == 'A']
b_items = [item for item in data if item[2] == 'B']

# Сортируем изделия A по цене (от дешевых к дорогим)
a_items.sort(key=lambda x: x[0])

# Сортируем изделия B по цене (от дешевых к дорогим)
b_items.sort(key=lambda x: x[0])

# Покупаем сначала все изделия A
total_cost = 0
for item in a_items:
    cost, count, typ = item
    # Покупаем столько изделий, сколько возможно
    for _ in range(count):
        if total_cost + cost <= m:
            total_cost += cost
        else:
            break

# Покупаем изделия B на оставшиеся деньги
b_count = 0
b_total_cost = 0
for item in b_items:
    cost, count, typ = item
    # Покупаем столько изделий, сколько возможно
    for _ in range(count):
        if total_cost + cost <= m:
            total_cost += cost
            b_count += 1
            b_total_cost += cost
        else:
            break

print(b_count, b_total_cost)  #5101 854276"""

# Hometask 02.02
# 1
# Не решено
"""
Задача 1 #49390
Для перевозки партии грузов различной массы выделен грузовик, 
но его грузоподъёмность ограничена, поэтому перевезти сразу все грузы не удастся. 
Грузы массой от 180 до 200 кг грузят в первую очередь, выбирая грузы по убыванию массы, начиная с самого тяжёлого. 
На оставшееся после этого место стараются взять как можно большее количество грузов. 
Если это можно сделать несколькими способами, выбирают тот способ, 
при котором самый большой из выбранных грузов имеет наибольшую массу. 
Если и при этом условии возможно несколько вариантов, выбирается тот, 
при котором наибольшую массу имеет второй по величине груз, и т.д. 
Известны количество грузов, масса каждого из них и грузоподъёмность грузовика. 
Необходимо определить количество и общую массу грузов, которые будут вывезены при погрузке по вышеописанным правилам. 
Входные данные представлены в файле 26.txt следующим образом. 
В первой строке входного файла записаны два целых числа: 
N – общее количество грузов и M – грузоподъёмность грузовика в кг. 
Каждая из следующих N   строк содержит одно целое число – массу груза в кг. 
В ответе запишите два целых числа без пробела: сначала максимально возможное количество грузов, затем их общую массу.
Пример организации исходных данных во входном файле:
6 700
100
185
120
160
140
300
В данном случае сначала нужно взять груз массой 185 кг. 
Остается 515 кг. После этого можно вывезти ещё максимум 3 груза. 
Это можно сделать четырьмя способами: 100 + 120 + 140, 100 + 140 + 160, 100 + 120 + 160, 120 + 140 + 160. 
Выбираем способ, при котором вывозится груз наибольшей возможной массы. 
Таких способов три: 100 + 120 + 160, 100 + 140 + 160, 120 + 140 + 160. 
Из этих способов выбираем те, при которых больше масса второго по величине груза, 
то есть 100 + 140 + 160 и 120 + 140 + 160. 
Их них нужно выбрать вариант 120 + 140 + 160, так как в этом случае третий по величине груз наиболее тяжёлый. 
Всего получается 4 груза общей массой 605 кг."""
"""# Открываем файл для чтения
file = open("26.txt")

# Считываем первую строку файла и извлекаем количество грузов (n) и грузоподъёмность (m)
n, m = map(int, file.readline().split())

# Создаем пустой список для хранения масс грузов
array = []

# Читаем оставшиеся строки файла и добавляем массы грузов в массив
for line in file:
    array.append(int(line.strip()))  # Преобразуем каждую строку в целое число и добавляем в массив

# Сортируем массив по возрастанию массы грузов
array = sorted(array)

# Инициализируем переменные
i = 0  # Индекс для прохода по массиву
current_sum = 0  # Текущая масса выбранных грузов
last_elem = 0  # Масса последнего добавленного груза
ind_last = 0  # Индекс последнего добавленного груза в первой итерации
count = 0  # Количество выбранных грузов

# Первая часть: выбираем грузы весом от 180 до 200 кг
while i < len(array) and array[i] <= 200:
    if array[i] >= 180 and current_sum + array[i] <= m:
        current_sum += array[i]  # Добавляем массу груза к текущей сумме
        last_elem = array[i]  # Обновляем массу последнего добавленного груза
        count += 1  # Увеличиваем счетчик выбранных грузов
    else:
        ind_last = i  # Запоминаем индекс, если не удалось добавить груз
    i += 1  # Переходим к следующему грузу

# Вторая часть: выбираем грузы с меньшей массой до индекса ind_last
for j in range(ind_last):
    if current_sum + array[j] <= m:
        current_sum += array[j]  # Добавляем массу груза к текущей сумме
        last_elem = array[j]  # Обновляем массу последнего добавленного груза
        count += 1  # Увеличиваем счетчик выбранных грузов

# Третья часть: выбираем грузы с большей массой, начиная с индекса i
for j in range(i, len(array)):

    if current_sum + array[j] <= m:
        current_sum += array[j]  # Добавляем массу груза к текущей сумме
        last_elem = array[j]  # Обновляем массу последнего добавленного груза
        count += 1  # Увеличиваем счетчик выбранных грузов

# Вычисляем оставшееся место в грузовике
free_space = m - current_sum + last_elem

# Четвертая часть: ищем максимальный элемент, который можно добавить без превышения свободного места
for i in range(len(array) - 1, -1, -1):
    if array[i] <= free_space:  # Проверяем, помещается ли груз в оставшееся место
        current_sum += array[i] - last_elem  # Обновляем сумму, заменяя последний добавленный груз
        break  # Выходим из цикла после добавления

# Выводим результаты: количество выбранных грузов и их общую массу
print(count, current_sum)  # 118 10000"""

# 2
"""Задача 1 #25597
Задание выполняется с использованием прилагаемых файлов
Предприятие производит оптовую закупку некоторых изделий A и B, на которую выделена определённая сумма денег. 
У поставщика есть в наличии партии этих изделий различных модификаций по различной цене. 
На выделенные деньги необходимо приобрести как можно больше изделий A независимо от модификации. 
Если у поставщика закончатся изделия A, то на оставшиеся деньги необходимо приобрести как можно больше изделий B. 
Предприятие хочет закупить как можно больше деталей, 
но если при одинаковом количестваве деталей можно получить разную цену, 
то предприятие хочет оставить как можно больше денег себе.
Известны выделенная для закупки сумма, а также количество и цена различных модификаций данных изделий у поставщика. 
Необходимо определить, сколько будет закуплено изделий B и какая сумма останется неиспользованной.
Входные данные
Первая строка входного файла содержит два целых числа: 
N – общее количество партий изделий у поставщика и M – сумма выделенных на закупку денег (в рублях). 
Каждая из следующих N строк описывает одну партию и содержит два целых числа 
(цена одного изделия в рублях и количество изделий в партии) и один символ (латинская буква A или B), 
определяющий тип изделия. Все данные в строках входного файла отделены одним пробелом.
В ответе запишите два целых числа через пробел: сначала количество закупленных изделий типа B, 
затем оставшуюся неиспользованной сумму денег.
Пример входного файла
4 1000
30 8 A
50 12 B
40 14 A
30 60 B
В данном случае сначала нужно купить изделия A: 8 изделий по 30 рублей и 14 изделий по 40 рублей. 
На это будет потрачено 800 рублей. На оставшиеся 200 рублей можно купить 6 изделий B по 30 рублей. 
Таким образом, всего будет куплено 6 изделий B и останется 20 рублей. В ответе надо записать числа 6 и 20."""
"""f = open('files/Задание_26__tsb8.txt')
n, m = map(int, f.readline().split())  # 500 4000000
data = []
for i in range(n):
    cost, count, typ = f.readline().split()
    data.append([int(cost), int(count), str(typ)])
data.sort(key=lambda x: (x[2], x[0]))

buy = []
buy_b_count = 0
buy_b = []
f = False
for i in range(len(data)):
    if f:
        break
    for count in range(data[i][1]):
        if sum(buy) + data[i][0] <= m:
            buy.append(data[i][0])
            if data[i][2] == 'B':
                buy_b_count += 1
        else:
            print(buy_b_count, m - sum(buy))  # 5895 227
            f = True
            break"""

# 3 - не решено
# #86441
"""#86441 На производстве штучных изделий N деталей должны быть отшлифованы и окрашены. 
Для каждой детали известно время её шлифовки и время окрашивания. 
Детали пронумерованы начиная с единицы. Параллельная обработка деталей не предусмотрена. 
На ленте транспортёра имеется N мест для каждой из N деталей. 
На ленте транспортёра детали располагают по следующему алгоритму:
— все 2N чисел, обозначающих время окрашивания и шлифовки для N деталей, упорядочивают по возрастанию;
— если минимальное число в этом упорядоченном списке — это время шлифовки конкретной детали, 
то деталь размещают на ленте транспортёра на первое свободное место от её начала;
— если минимальное число — это время окрашивания, 
то деталь размещают на первое свободное место от конца ленты транспортёра.
— если число обозначает время окрашивания или шлифовки уже рассмотренной детали, то его не принимают во внимание.
Этот алгоритм применяется последовательно для размещения всех N деталей. Определите номер предпоследней детали, 
для которой будет определено её место на ленте транспортёра, и количество деталей, которые будут покрашены до неё.
Входные данные:
В первой строке входного файла находится натуральное число N (N < 1000) – количество деталей. 
Следующие N строк содержат пары чисел, обозначающих соответственно время шлифовки и 
время окрашивания конкретной детали (все числа натуральные, различные).
Запишите в ответе два натуральных числа через пробел: сначала номер предпоследней детали, 
для которой будет определено её место на ленте транспортёра, 
затем количество деталей, которые будут покрашены до неё."""
# Valeria 07.02
"""file = open('files/26_1M__3whph.txt')
k = int(file.readline())  # 997 # кол-во деталей
array_details = []
for i in range(k):
    detail = list(map(int, file.readline().split()))
    if detail[0] > detail[1]:
        array_details.append((detail[1], 'paint', i + 1))
    else:
        array_details.append((detail[0], 'grinding', i + 1))
array_details.sort()
lenta = [0] * k
det = []  # размещенные детали
for detail in array_details:
    if detail[1] == 'grinding':
        for i in range(len(lenta)):
            if lenta[i] == 0:
                lenta[i] = 1
                det.append(detail)
                break
    else:
        for i in range(len(lenta) - 1, -1, -1):
            if lenta[i] == 0:
                lenta[i] = 1
                det.append(detail)
                break
print(det[-2][2], len([x for x in det[:-2] if x[1] == 'paint']))  # 798 508"""

# shkolkovo
"""file = open('26_9793.txt')
count_details = int(file.readline())
array_details = []  # список, в котором у нас будут все детали файла
for i in range(count_details):
    detail = list(map(int, file.readline().split()))
    if detail[0] > detail[1]:  # если второе число меньше первого
        array_details.append((detail[1], 'paint', i + 1))  # то добавляем второе число, указываем,
        # что эту деталь отправим на покраску и передаём её номер
    else:  # в ином случае
        array_details.append((detail[0], 'grind', i + 1))  # тогда добавляем первое число, указываем,
        # что эту деталь отправим на шлифовку и передаём её номер
array_details.sort()
lenta = [0] * count_details  # симулируем ленту транспортёра
details = []  # список, в котором у нас будут детали, которые мы положили на ленту
for detail in array_details:  # проход по всевозможным деталям файла
    if detail[1] == 'grind':  # если эту деталь нужно отправить на шлифовку
        for i in range(len(lenta)):  # то делаем перебор с начала ленты
            if lenta[i] == 0:  # если эта ячейка свободна
                lenta[i] = 1  # указываем, что она занята
                details.append(detail)
                break  # сброс цикла для того, чтобы перейти к следующей детали
    else:  # в ином случае
        for i in range(len(lenta) - 1, -1, -1):  # перебор с конца ленты
            if lenta[i] == 0:  # если эта ячейка свободна
                lenta[i] = 1  # указываем, что она занята
                details.append(detail)
                break  # сброс цикла для того, чтобы перейти к следующей детали
# выводим номер, предпоследней детали, а также количество покрашенных деталей до этой детали
print(details[-2][2], len([x for x in details[:-2] if x[1] == 'paint']))  # 798 508"""

# 4
"""Задача 4#18208
Системный администратор раз в неделю создаёт архив пользовательских файлов. 
Однако объём диска, куда он помещает архив, может быть меньше, чем суммарный объём архивируемых файлов. 
Известно, какой объём занимает файл каждого пользователя.
По заданной информации об объёме файлов пользователей и 
свободном объёме на архивном диске определите максимальное число пользователей, 
чьи файлы можно сохранить в архиве, а также максимальный размер имеющегося файла, 
который может быть сохранён в архиве, при условии, что сохранены файлы максимально возможного числа пользователей.
Входные данные
В первой строке входного файла находятся два числа: 
S   — размер свободного места на диске (натуральное число, не превышающее 10 000) и 
N   — количество пользователей (натуральное число, не превышающее 1000). 
В следующих N строках находятся значения объёмов файлов каждого пользователя 
(все числа натуральные, не превышающие 100), каждое в отдельной строке.
Запишите в ответе два числа через пробел: сначала наибольшее число пользователей, 
чьи файлы могут быть помещены в архив, затем максимальный размер имеющегося файла, 
который может быть сохранён в архиве, при условии, что сохранены файлы максимально возможного числа пользователей."""

"""f = open('files/Задание_26__shd2.txt')
s, n = map(int, f.readline().split())  # 1987 4625
data = []
for i in range(n):
    data.append(int(f.readline()))
data.sort()

achive = []
i = 0
for i in range(n):
    if sum(achive) + data[i] < s:
        achive.append(data[i])
    else:
        extra = s - sum(achive)  # 8
        break

print(data)
print(achive)
mx = [x+extra for x in achive if x <= extra + achive[-1]]
print(len(achive), max(mx))  # 397 17"""
# shkolkovo
"""file = open("Задание 26.txt", "r", encoding="UTF-8")
lines = file.readlines()

s, n = map(int, lines[0].split())
array = list(map(int, lines[1:]))
array = sorted(array)

users_count = 0
maximum_file = 0
current_summ = 0
i = 0
while i < n:
    if current_summ + array[i] > s:
        break
    current_summ += array[i]
    i += 1

users_count = i
current_summ -= array[i - 1]

while i < n:
    if current_summ + array[i] > s:
        break
    i += 1
current_summ += array[i - 1]
maximum_file = array[i - 1]

print(users_count, maximum_file)  # 397 17"""

# 86442
"""На производстве штучных изделий N деталей должны быть отшлифованы и окрашены. 
Для каждой детали известно время её шлифовки и время окрашивания. Детали пронумерованы начиная с единицы. 
Параллельная обработка деталей не предусмотрена. На ленте транспортёра имеется N мест для каждой из N деталей. 
На ленте транспортёра детали располагают по следующему алгоритму:
— все 2N чисел, обозначающих время окрашивания и шлифовки для N деталей, упорядочивают по возрастанию;
— если минимальное число в этом упорядоченном списке — это время шлифовки конкретной детали, 
то деталь размещают на ленте транспортёра на первое свободное место от её начала;
— если минимальное число — это время окрашивания, 
то деталь размещают на первое свободное место от конца ленты транспортёра.
- из-за низкокачественных,безответственных сотрудников для каждой 5 детали определяется куда отправится деталь 
не по минимальному числу, а по максимальному.
— если число обозначает время окрашивания или шлифовки уже рассмотренной детали, то его не принимают во внимание.
Этот алгоритм применяется последовательно для размещения всех N деталей. 
Определите номер последней детали, отправленной на покраску, 
для которой будет определено её место на ленте транспортёра, затем количество деталей, назначенных на отшлифовку, 
расположенных на второй половине ленты.
Входные данные:
В первой строке входного файла находится натуральное число N (N < 1000) – количество деталей. 
Следующие N строк содержат пары чисел, обозначающих соответственно время шлифовки и 
время окрашивания конкретной детали (все числа натуральные, различные).
Запишите в ответе два натуральных числа через пробел: сначала номер последней детали, 
отправленной на покраску, для которой будет определено её место на ленте транспортёра, 
затем количество деталей, назначенных на отшлифовку, расположенных на второй половине ленты."""

"""file = open('files/26_4M__3whpp.txt')
k = int(file.readline())  # 997
array_details = []
for i in range(k):
    detail = list(map(int, file.readline().split()))
    if (i + 1) % 5 == 0:
        if detail[0] > detail[1]:
            array_details.append((detail[0], 'grinding', i + 1))
        else:
            array_details.append((detail[1], 'paint', i + 1))
    else:
        if detail[0] > detail[1]:
            array_details.append((detail[1], 'paint', i + 1))
        else:
            array_details.append((detail[0], 'grinding', i + 1))
array_details.sort()
det = []
lenta = [0] * k
for detail in array_details:
    if detail[1] == 'grinding':
        for i in range(len(lenta)):
            if lenta[i] == 0:
                lenta[i] = detail
                det.append(detail)
                break
    else:
        for i in range(len(lenta) - 1, -1, -1):
            if lenta[i] == 0:
                lenta[i] = detail
                det.append(detail)
                break

s = lenta[k//2:]

print([x[2] for x in det if x[1] == 'paint'][-1])  # 895
print(len([x for x in s if x[1] == 'grinding']))  # 18"""

# № 1
"""Запишите в ответе два натуральных числа через пробел: сначала количество деталей, 
которые будут отшлифованы, затем номер последней обработанной детали."""
"""f = open('files/26_1__3whs4.txt')
c = int(f.readline())  # 1000
array_details = []
for i in range(c):
    detail = list(map(int, f.readline().split()))  # шлифовка, окраска
    if detail[0] < detail[1]:
        array_details.append((detail[0], 'grinding', i + 1))
    else:
        array_details.append((detail[1], 'paint', i + 1))
array_details.sort()
details = []
lenta = [0] * c
for detail in array_details:
    if detail[1] == 'grinding':
        for i in range(len(lenta)):
            if lenta[i] == 0:
                lenta[i] = detail
                details.append(detail)
                break
    else:
        for i in range(len(lenta) - 1, -1, -1):
            if lenta[i] == 0:
                lenta[i] = detail
                details.append(detail)
                break
print(sum(1 for x in details if x[1] == 'grinding'))  # 484
print(details[-1][2])  # 544"""

# № 2
"""Запишите в ответе два натуральных числа через пробел: сначала время обработки детали, 
которая в итоге будет стоять на ленте транспортера на 168 месте, а затем суммарное время окрашивания деталей."""
"""f = open('files/26_3__3whrj.txt')
c = int(f.readline())  # 940
array_details = []
for i in range(c):
    detail = list(map(int, f.readline().split()))  # grinding, painting
    if detail[0] > detail[1]:
        array_details.append((detail[0], 'grinding', i+1))
    else:
        array_details.append((detail[1], 'painting', i+1))
array_details.sort(reverse=True)

lenta = [0] * c
for detail in array_details:
    if detail[1] == 'grinding':
        for i in range(len(lenta)):
            if lenta[i] == 0:
                lenta[i] = list(detail)
                break
    else:
        for i in range(len(lenta) - 1, -1, -1):
            if lenta[i] == 0:
                lenta[i] = list(detail)
                break

print(lenta[168-1][0])  # 1475
print(sum(x[0] for x in lenta if x[1] == 'painting'))  # 616262"""

# № 3
"""f = open('files/26_12__491va.txt')
c = int(f.readline())  # 900
array_details = []
for i in range(c):
    detail = list(map(int, f.readline().split()))
    if detail[1] > detail[0]:
        array_details.append((detail[1], 'painting', i))
    else:
        array_details.append((detail[0], 'grinding', i))
array_details.sort(reverse=True)  # т.к. максимальное

lenta = [0] * c
for detail in array_details:
    if detail[1] == 'painting':
        for i in range(len(lenta)):
            if lenta[i] == 0:
                lenta[i] = detail
                break
    else:
        for i in range(len(lenta) - 1, -1, -1):
            if lenta[i] == 0:
                lenta[i] = detail
                break
print(len([x for x in lenta if x[1] == 'painting']))  # 451
print([x[2] for x in lenta if x[1] == 'grinding'][-1])  # 646"""

# 29461
"""file = open('files/Задание_26__rg3w.txt')
lines = file.readlines()
n = int(lines[0])
array = list(map(int, lines[1:]))
array = sorted(array)

i = 0
tek = 0
while array[i] <= 130:
    tek += array[i]
    i += 1
t = i + (n - i) // 2 + (n % 2)
t = 4815 + (9300 - 4815) // 2 + (9300 % 2)

ans = tek + sum(array[t:]) + sum(array[i:t]) // 2 + sum(array[i:t]) % 2

print(ans, array[t - 1])"""

# 30259
"""file = open('files/4__tdop.txt')
lines = file.readlines()
n = int(lines[0])
array = list(map(int, lines[1:]))
array = sorted(array)

i = 0
s = 0
m = 0
while array[i] <= 200:
    s += array[i]
    i += 1

t = (n - i) // 2
while t > 0:
    s += array[i] * 0.7
    m = array[i]
    i += 1
    t -= 1

if (s + sum(array[i:])) % 1 != 0:
    print(int(s + sum(array[i:])) + 1, m)
else:
    print(int(s + sum((array[i:]))), m)"""

# 55489
"""from math import ceil

f = open('files/7__1i2do.txt')
n = int(f.readline())  # 1000
data = []

for i in range(n):
    data.append(int(f.readline()))
data.sort()

n_50 = sum(1 for x in data if x > 50) // 2
c = 0
mx = 0
for i in range(n):
    if data[i] > 50 and c < n_50:
        c += 1
        mx = max(mx, data[i])
        data[i] = data[i] * 0.75
print(ceil(sum(data)), mx)  # 478739 530"""

# 55490
"""f = open('files/8__1i2dt.txt')
n = int(f.readline())
data = []
for i in range(n):
    data.append(int(f.readline()))
data.sort()
mx = 0
n_100 = sum(1 for x in data if x > 100) // 3
c = 0
for i in range(n):
    if data[i] > 100 and c < n_100:
        mx = max(mx, data[i])
        data[i] = data[i] * 0.7
        c += 1
print(sum(data), mx)  # 480786 397"""

# 57342
"""from math import ceil

f = open('files/26_23__1kuc9.txt')
n = int(f.readline())
data = []
for i in range(n):
    data.append(int(f.readline()))
data.sort()

n_153 = sum(1 for x in data if x > 153) // 4
mx = 0
c = 0
data_simple = []
for i in range(n):
    if data[i] > 153 and c < n_153:
        mx = max(mx, data[i])
        data[i] = data[i] * 0.6
        c += 1
    elif data[i] <= 153:
        data_simple.append(data[i])

print(ceil(sum(data)), (sum(data_simple) // len(data_simple)))  # 491165 86"""

# 61598
"""f = open('files/26-2__2yr4z.txt')
k, n = map(int, f.readline().split())  # 120 100000
a = []
for i in range(n):
    sdacha, osvob = map(int, f.readline().split())
    a.append((sdacha, osvob))
a.sort()  # отсортировали по времени сдачи
c = 0  # кол-во багажа
z = -1  # номер последней занятой ячейки
bag = [-1] * k  # время освобождения для каждой ячейки
for i in range(n):
    sdacha = a[i][0]
    osvob = a[i][1]
    for j in range(k):
        if sdacha > bag[j]:
            bag[j] = osvob
            c += 1
            z = j + 1
            break
print(c, z)  # 5894 119"""

"""f = open('files/26__2y9ji.txt')
k = int(f.readline())
n = int(f.readline())
a = []
for i in range(n):
    sdacha, osvob = map(int, f.readline().split())
    a.append((sdacha, osvob))
a.sort()  # отсортировали по времени сдачи
c = 0
z = 0
bag = [0] * k
for i in range(n):
    sdacha = a[i][0]
    osvob = a[i][1]
    for j in range(k):
        if sdacha > bag[j]:
            bag[j] = osvob
            c += 1
            z = j + 1
            break
print(c, z)  # 581 2"""
# #63605
"""f = open('files/26_6__3mk0m.txt')
kol_kamera = int(f.readline())
kol_pas = int(f.readline())
pas = sorted(list(map(int, i.split())) for i in f)
zanato = [-1] * kol_kamera
c = 0
time = [0 for i in range(3200)]
k_m = 0
for p in pas:
    for i in range(kol_kamera):
        if p[0] > zanato[i]:
            zanato[i] = p[0] + p[1]
            c += 1
            for m in range(p[0], p[0] + p[1]):
                time[m] += 1
            break

for x in time:
    if x == kol_kamera:
        k_m += 1

print(kol_pas - c, k_m)  # 585 1059"""

"""file = open('files/26_6__3mk0m.txt')
count_cameras = int(file.readline())  # количество камер хранения
count_client = int(file.readline())  # количество пассажиров
array_client = sorted(list(map(int, i.split())) for i in file)
cameras = [-1] * count_cameras  # камеры хранения. каждый элемент списка - это камера хранения.
# в ячейки будем записывать время освобождения определенной камеры хранения
count = 0  # количество человек, которые смогли положить вещи в камеру хранения
# временной промежуток от 0 до 3500 минут. Каждый элемент списка это определенная минута.
# Значение под определенной ячейкой - это количество занятых камер в данную минуту
time = [0 for i in range(3500)]
count_minute = 0  # количество минут, в течении которых были заняты все камеры
for client in array_client:  # проход по клиентам
    for i in range(len(cameras)):  # проход по камерам хранения
        # если время прихода текущего клиента больше чем время освобождения данной камеры
        if client[0] > cameras[i]:
            cameras[i] = client[0] + client[1]  # тогда записываем время освобождения данной камеры текущим клиентом
            count += 1
            # проходимся по минутам от времени прихода до времени ухода текущего клиента
            for minute in range(client[0], client[0] + client[1]):
                time[minute] += 1  # отмечаем под каждой минутой, что на одну камеру стало занято больше
            break  # прерываем цикл, так как текущий клиент уже положил свои вещи и переходим к следующему клиенту
for i in time:  # проход по отрезку времени
    if i == count_cameras:  # если количество занятых камер равно количеству камер в файле
        count_minute += 1  # увеличиваем счётчик минут, в течении которого были заняты все камеры
# количество людей, которые не смогли положить вещи можно посчитать следующим образом:
# общее кол-во людей - кол-во людей положивших вещи в камеру
print(count_client - count, count_minute)  # 585 1059"""

# ДЗ
"""В аэропорту есть камера хранения из K   ячеек, которые пронумерованы с 1. 
Принимаемый багаж кладется в свободную ячейку с минимальным номером. 
Известно время, когда пассажиры сдают и забирают багаж (в минутах с начала суток). 
Ячейка доступна для багажа, начиная со следующей минуты, после окончания срока хранения. 
Если свободных ячеек не находится, то багаж не принимается в камеру хранения. 
Если 2 пассажира одновременно приходят сдавать багаж, то в раньше ячейку багаж кладет тот, кто раньше забирает.
Найдите количество багажей, которое будет сдано в камеры за 24 часа и наибольший номер ячейки, 
в которую сдаст багаж последний пассажир.
В первой строке входного файла находится число K   – количество ячеек в камере хранения, 
во второй строке файла число N   – количество пассажиров, сдающих багаж (натуральное число, не превышающее 1000). 
Каждая из следующих N   строк содержит два натуральных числа, не превышающих 1440: 
время сдачи багажа и время выдачи багажа.
Программа должна вывести два числа через пробел: количество сданных в камеру хранения багажей и наибольший номер ячейки, 
в которую примут багаж у последнего пассажира, который сможет сдать багаж."""
# 61642
# 1
"""f = open('files/26__1udco.txt')
k = int(f.readline())
n = int(f.readline())
pas = sorted(list(map(int, x.split())) for x in f)
cameras = [-1] * k
count = 0
last_count = 0
for i in range(n):
    for j in range(k):
        time_sdacha = pas[i][0]
        time_vidacha = pas[i][1]
        if cameras[j] < time_sdacha:
            cameras[j] = time_vidacha
            count += 1
            last_count = j + 1
            break
print(count, last_count)  # 835 2"""

"""Досрочная волна 2023

В аэропорту есть камера хранения из K ячеек, которые пронумерованы с 1. 
Принимаемый багаж кладется в свободную ячейку с минимальным номером. 
Известно время, когда пассажиры сдают и забирают багаж (в минутах с начала суток). Ячейка доступна для багажа, 
начиная со следующей минуты, после окончания срока хранения. Если свободных ячеек не находится, 
то багаж не принимается в камеру хранения.
Найдите количество багажа, которое будет сдано в камеры за 24 
часа и номер ячейки, в которую сдаст багаж последний пассажир.
Входные данные
В первой строке входного файла находится число K – количество ячеек в камере хранения, 
во второй строке файла число N   – количество пассажиров, сдающих багаж (натуральное число, не превышающее 1000  ). 
Каждая из следующих N строк содержит два натуральных числа, не превышающих 1440: 
время сдачи багажа и время выдачи багажа.
Выходные данные
Программа должна вывести два числа через пробел: количество сданных в камеру хранения багажа и номер ячейки, 
в которую примут багаж у последнего пассажира, который сможет сдать багаж."""
# 61887
# 2
"""f = open('files/26__1uvv8.txt')
k = int(f.readline())
n = int(f.readline())
pas = sorted(list(map(int, x.split())) for x in f)

cameras = [-1] * k
count = 0
k_last = 0
for i in range(n):
    for j in range(k):
        if cameras[j] < pas[i][0]:
            cameras[j] = pas[i][1]
            count += 1
            k_last = j + 1
            break
print(count, k_last)  # 586 3"""

# 63609
# 3
"""В отеле составляют недельный план уборки номеров после отъезда клиентов. 
Все номера одинаковые и пронумерованы с 1 до К. В основе плана журнал заявок, 
в каждой из которых записано время заезда и время выезда для N заявок. Заявки поступают в случайном порядке. 
На начало недели все номера подготовлены к заселению.
После отъезда клиента на уборку номера отводится 45 минут. 
Уборка начинается в следующую минуту после освобождения номера. 
Клиент может заезжать в подготовленный номер в следующую минуту после уборки.
Если подготовленных номеров несколько, то выбирается номер с максимальным временем простоя. 
Если время простоя одинаковое, то в последний номер. Если подготовленных номеров нет, 
клиент ждет первый подготовленный номер. При этом время отъезда не меняется.
Найти максимальное время ожидания клиента перед заселением и последний заселенный на планируемой неделе номер. 
Из-за ожидания заселение может произойти на следующей неделе, что будет учитывается в планах следующей недели. 
Числа в ответе запишите через пробел.
Входные данные: На первой строке одно число K – количество номеров. 
На второй строке одно число N – количество заявок. 
Далее N строк, в каждой из которых указано время заезда и время выезда в минутах, начиная с 0:00 воскресенья."""
# k – количество номеров
# n – количество заявок
# data — список со всеми данными

"""f = open('files/26_10__1vn9i.txt')
k = int(f.readline())
n = int(f.readline())
data = [list(map(int, f.readline().split())) for i in range(n)]
data.sort()

freeTime = [0] * k  # время готовности каждого номера
maxWait = 0  # максимальное время ожидания клиента перед заселением
lastRoom = -1  # последний заселенный на планируемой неделе номер
for start, end in data:
    rn = 0  # для номера с макс. простоем
    for i in range(1, k):
        # Если из этого номера выехали раньше, чем из остальных,
        # то сохраняем его
        if freeTime[i] <= freeTime[rn]:
            rn = i
    # Расчёт максимального времени ожидания клиента перед заселением.
    # Если получится так, что к приезду клиента не будет свободного номера,
    # то он может заселиться в номер, который освободится раньше через какое-то время.
    # Здесь мы это время и рассчитываем.
    # Если доступный номер будет,
    # то разность будет отрицательной, значение maxWait так и останется 0
    maxWait = max(freeTime[rn] - start, maxWait)
    # Если в номер можно заселиться и проживание будет на этой неделе,
    # то сохраняем номер. Также сохраняем в списке значение выезда из номера.
    if freeTime[rn] <= end and freeTime[rn] < 7 * 24 * 60:
        freeTime[rn] = end + 46
        lastRoom = rn + 1

print(maxWait, lastRoom)  # 122 11"""

"""f = open('files/26_10__1vn9i.txt')
k = int(f.readline())
n = int(f.readline())
clients = sorted(list(map(int, s.split())) for s in f)

numers = [-1] * k
mx_ojid = 0
last_numer = 0

for start, end in clients:
    p = 0
    for i in range(1, k):
        if numers[i] <= numers[p]:
            p = i
    mx_ojid = max(numers[p] - start, mx_ojid)

    if numers[p] <= end and numers[p] < 7 * 24 * 60:
        numers[p] = end + 45 + 1
        last_numer = p + 1

print(mx_ojid, last_numer)  # 122 11"""

# Атракционы
"""f = open('files/26_11__1vn9j.txt')
k, n = map(int, f.readline().split())
a = sorted([list(map(int, i.split())) for i in f])

count = 0
last = 0
time_kat = [-1] * k
time_kon = [-1] * k
for x in a:
    st, end = x
    for j in range(k):
        if (st > time_kon[j]) or (st == time_kat[j]):
            count += 1
            time_kat[j] = st
            time_kon[j] = end
            last = j + 1
            break
print(count, last)  # 466 102"""

# Автостоянка
"""f = open('files/26_1__1vn98.txt')
count_car = int(f.readline())

c = []
for i in range(count_car):
    st, duration, type_c = f.readline().split()
    st, duration = int(st), int(duration)
    if type_c == 'A':
        type_c = 0
    else:
        type_c = 1
    c.append([st, duration, type_c])
c.sort()
park = [[-1 for i in range(180)], [-1 for i in range(20)]]
parked_c = 0
parked_b = 0
for st, duration, type_c in c:
    f = False
    for y in range(type_c, 2):
        for i in range(len(park[y])):
            if st >= park[y][i]:
                park[y][i] = st + duration
                parked_c += 1
                if type_c == 1:
                    parked_b += 1
                f = True
                break
        if f:
            break
print(parked_b, count_car - parked_c)  # 143 12"""
# 63606
# Салон красоты
"""В некотором салоне красоты есть К мест для процедур. После каждого клиента место необходимо убрать, на это уходит 10 минут. 
Уборка начинается в следующую минуту после того, как уходит клиент. 
Новый клиент может сесть в следующую минуту после завершения уборки. 
Салон работает с 7:00 и закрывается в 24:00. Все клиенты должны уйти не позже 24:00. 
За это время в него приходит N клиентов. При этом гарантируется, что они придут не раньше 7:00, 
а планируют уйти не позже 24:00.
Каждого клиента при входе встречает администратор и подбирает для него место с минимальным номером. 
Может случиться так, что несколько людей придет одновременно, 
тогда администратор в первую очередь подбирает место для того, кто планирует сидеть меньшее время. 
В случае если все места заняты, клиент готов подождать не более 20 минут, 
при этом за местом он пробудет обязательно T минут (T – разница между временем прибытия и отбытия), 
в этом случае выбирается место, которое освободится раньше всех. Если мест несколько, выбирается с меньшим номером.
Входные данные. На первой строке одно число N – количество клиентов, пришедших за день. 
На второй строке одно число K – количество мест в салоне. Далее N строк, в каждой из которых указано время, 
когда клиент пришел и время, до которого он планировал пробыть в салоне (время дано в минутах от начала дня).
Определите, сколько клиентов получится обслужить за время работы салона и номер места, 
за который сядет последний клиент. Числа в ответе запишите через пробел."""

"""f = open('files/26_7__1vn9f.txt')
n = int(f.readline())  # считываем количество пришедших клиентов
k = int(f.readline())  # считываем количество мест в салоне

clients = []  # список клиентов
for line in f.readlines():
    a, b = map(int, line.split())
    clients.append([a, b])
clients.sort()  # сортируем список клиентов
table = [-1] * k  # список, симулирующий каждое рабочее место, в котором будет записано время, в которое освободится каждое место
ans1 = 0
ans2 = 0
for client in clients:  # проход по каждому клиенту
    ok = False  # флаг, которые показывает нужно ли человеку ждать или нет
    for i in range(k):  # проход по всем рабочим местам в салоне
        # если время прихода текущего клиента больше чем время освобождения данного места другим клиентом и при этом текущий клиент уйдёт ранее закрытия магазина
        if client[0] > table[i] and client[1] <= 1440:
            table[i] = client[
                           1] + 10  # записываем время ухода текущего клиента с учётом уборки данного места после него
            ok = True  # помечаем, что для текущего клиента нашли место
            ans1 += 1  # увеличиваем счётчик пришедших клиентов
            ans2 += i + 1  # запоминаем номер места, куда сел последний клиент
            break  # прерываем цикл - переходим к следующему клиенту
    if not ok:  # если клиенту нужно подождать
        mt = min(table)  # определяем место, которое освободится в ближайшее время
        mintime = mt - client[0] + 1  # определяем время, которое человеку нужно подождать прежде чем сесть за него
        # если время ожидания не более 20 минут
        if mintime <= 20:
            ind = table.index(mt)  # определяем индекс данного места в списке
            T = client[1] - client[0]  # считаем время T
            if table[ind] + 1 + T <= 1440:  # если данный клиент уйдёт не позже закрытия
                table[ind] += 1 + T + 10  # то сажаем данного человека за место
                ans1 += 1  # увеличиваем счётчик пришедших клиентов
                ans2 = ind + 1  # запоминаем номер места, куда сел последний клиент
print(ans1, ans2)  # 1926 93"""

"""f = open('files/26_7__1vn9f.txt')
n = int(f.readline())
k = int(f.readline())
kl = []
for x in f:
    t_p, t_y = map(int, x.split())
    kl.append([t_p, t_y])
kl.sort()
spot = [-1] * k
a = 0  # уже обслужили
b = 0  # номер
for c in kl:
    f = False
    for i in range(k):
        if c[0] > spot[i] and c[1] <= 1440:
            spot[i] = c[1] + 10
            f = True
            a += 1
            b += i + 1
            break
    if not f:
        mt = min(spot)
        time_min = mt - c[0] + 1
        if time_min <= 20:
            ind = spot.index(mt)
            T = c[1] - c[0]
            if spot[ind] + 1 + T <= 1440:
                spot[ind] += 1 + T + 10
                a += 1
                b = ind + 1
print(a, b)  # 1926 93"""

# ДЗ 17.02
# 1
"""f = open('files/1__1vrj4.txt')
m = int(f.readline())
k = int(f.readline())
data = sorted(list(map(int, s.split())) for s in f)

numers = [-1] * k
count = last = 0
for i in range(m):
    for j in range(k):
        if numers[j] < data[i][0]:
            numers[j] = data[i][0] + data[i][1]
            count += 1
            last = j + 1
            break
print(count, last)  # 243 5"""

# 2
# 63614
"""В городе открылось кафе. В нем есть К столиков. 
После каждого клиента столик необходимо убрать, на это уходит 8 минут. 
Уборка начинается в следующую минуту после того, как уходит гость. 
Новый клиент может сесть в следующую минуту после завершения уборки. Кафе работает с 7:00 и закрывается в 23:00. 
Все клиенты должны уйти не позже 23:00. За это время в него приходит N клиентов. 
(Гарантируется, что они придут не раньше 7:00, а планируют уйти не позже 23:00).
Каждого гостя при входе встречает администратор и подбирает для него стол с минимальным номером. Может случиться так, 
что несколько людей придет одновременно, тогда администратор в первую очередь подбирает столик для того, 
кто планирует сидеть меньшее время. В случае если все столы заняты, гость готов подождать не более 25 минут, 
при этом за столом он пробудет обязательно T минут (T – разница между временем прибытия и отбытия), 
в этом случае выбирается столик, который освободится раньше всего. Если таких несколько, выбирается с меньшим номером.
Определите, сколько клиентов получится обслужить за время работы кафе и номер столика, 
за который сядет последний клиент. В ответ запишите числа через пробел.
Входные данные. На первой строке одно число N – количество гостей, пришедших за день. 
На второй строке одно число K – количество столиков в кафе. Далее N строк, в каждой из которых указано время, 
когда клиент пришел и время, до которого он планировал пробыть в кафе (время дано в минутах от начала дня)."""
"""
f = open('files/26_15__1vn9n.txt')
n = int(f.readline())
k = int(f.readline())

clients = []  # список клиентов
for line in f.readlines():
    a, b = map(int, line.split())
    clients.append([a, b])
clients.sort()  # сортируем список клиентов
table = [-1] * k  # список, симулирующий каждое рабочее место, в котором будет записано время, в которое освободится каждое место
ans1 = 0
ans2 = 0
for client in clients:  # проход по каждому клиенту
    ok = False  # флаг, которые показывает нужно ли человеку ждать или нет
    for i in range(k):  # проход по всем рабочим местам в салоне
        # если время прихода текущего клиента больше чем время освобождения данного места другим клиентом и при этом текущий клиент уйдёт ранее закрытия магазина и придёт позже или во время открытия
        if client[0] > table[i] and client[0] >= 420 and client[1] <= 1380:
            table[i] = client[1] + 8  # записываем время ухода текущего клиента с учётом уборки данного места после него
            ok = True  # помечаем, что для текущего клиента нашли место
            ans1 += 1  # увеличиваем счётчик пришедших клиентов
            ans2 = i + 1  # запоминаем номер места, куда сел последний клиент
            break  # прерываем цикл - переходим к следующему клиенту
    if not ok:  # если клиенту нужно подождать
        mt = min(table)  # определяем индекс данного места в списке
        mintime = mt - client[0] + 1  # считаем время T
        if mintime <= 25:  # если время ожидания не более 25 минут
            ind = table.index(mt)  # определяем индекс данного места в списке
            T = client[1] - client[0]  # считаем время T
            if table[ind] + 1 + T <= 1380:  # если данный клиент уйдёт не позже закрытия
                table[ind] += 1 + T + 8  # то сажаем данного человека за место
                ans1 += 1  # увеличиваем счётчик пришедших клиентов
                ans2 = ind + 1  # запоминаем номер места, куда сел последний клиент
print(ans1, ans2)  # 4213 279"""

"""f = open('files/26_15__1vn9n.txt')
n = int(f.readline())
k = int(f.readline())
data = sorted(list(map(int, s.split())) for s in f)
count = last = 0
table = [-1] * k
for c in data:
    f = False
    for i in range(k):
        if c[0] > table[i] and c[1] <= 1380:
            table[i] = c[1] + 8
            f = True
            count += 1
            last = i + 1
            break
    if not f:
        mt = min(table)
        mintable = mt - c[0] + 1
        if mintable <= 25:
            ind = table.index(mt)
            T = c[1] - c[0]
            if table[ind] + 1 + T <= 1380:
                table[ind] += 1 + T + 8
                count += 1
                last = ind + 1
print(count, last)  # 4213 279"""

"""f = open('files/26_6__1vv35.txt')
A = int(f.readline())
B = int(f.readline())
C = int(f.readline())
tovar = sorted(list(map(int, f.readlines())))[::-1]

cameras = [C] * B
last = 0
for c in range(len(cameras)):
    for t in range(len(tovar)):
        if cameras[c] >= tovar[t]:
            cameras[c] -= tovar[t]
            tovar[t] = 0
            last = c + 1
        else:
            break
    for t in range(len(tovar)):
        if cameras[c] >= tovar[len(tovar) - t - 1]:
            cameras[c] -= tovar[len(tovar) - t - 1]
            if tovar[len(tovar) - t - 1] != 0:
                tovar[len(tovar) - t - 1] = 0
                last = c + 1
print(last, cameras[last - 1])  # 400 61"""
