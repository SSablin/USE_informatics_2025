# 18967
f = open('files/26_18967.txt')
n, k = [int(x) for x in f.readline().split()]
# n - общее кол-во мест, к - кол-во людей, которых нужно посмотреть
data = [[int(x) for x in s.split()] for s in f]
# ID, time, M - кол-во номерков
data.sort(key=lambda x: (x[1], x[0]))
# сортируем по времени подхода, если в одно время(совпадение), то по ID
visited = set()  # уже посетили
left = set()  # приходили, но покинули кинотеатр
top_top = time = 0
for i in range(len(data)):  # перебираем клиентов
    if data[i][0] not in visited:
        if n - data[i][2] >= 0:  # если есть место
            n -= data[i][2]
        else:
            top_top += data[i][2]
            left.add(data[i][0])
    else:
        if data[i][0] not in left:
            n += data[i][2]
    visited.add(data[i][0])  # отмечаем, что клиент обслужен
    if n == 0:  # не осталось свободного места в гардеробе
        time += data[i + 1][1] - data[i][1]
print(top_top, time)  # 5190 294

# 26
# https://youtu.be/GYogg6TOxts?si=7eP6AqZvgah2ATYu&t=4059
f = open('files/26_18492.txt')
n = int(f.readline())
data = [list(map(int, x.split())) for x in f]
timeline = [0] * 1441
for num, st, en in data:
    for mnt in range(st, en):
        timeline[mnt] += 1
pick = max(timeline)
intervals = []
end = 1
while end < 1441:
    if timeline[end] == pick and timeline[end - 1] < pick:
        start = end
        while timeline[end] == pick:
            end += 1
        intervals.append((end - start, sum(nm for nm, st, en in data if start <= st < end or st <= start < en)))
    end += 1
print(len(intervals), max(intervals)[1])  # 11 27785627

# 26
# №20161
f = open('files/26_20161.txt')
n = int(f.readline())
data = sorted(list(map(int, s.split())) for s in f)  # стоимость, номер категории
data_even = sorted([x[0] for x in data if x[1] % 2 == 0])
data_odd = sorted([x[0] for x in data if x[1] % 2 == 1], reverse=True)
count_even_30 = int(0.7 * len(data_even))
discount_even = []
discount_odd = []
for i in range(len(data_even)):
    if i < count_even_30:
        new_price = data_even[i] * 0.7
        if round(new_price) - new_price < 0.0001:
            discount_even.append(round(new_price))
        else:
            discount_even.append(int(new_price))
    else:
        new_price = data_even[i] * 0.8
        if round(new_price) - new_price < 0.0001:
            discount_even.append(round(new_price))
        else:
            discount_even.append(int(new_price))

count_odd = int(0.25 * len(data_odd))
for i in range(len(data_odd)):
    if i < count_odd:
        new_price = data_odd[i] * 0.85
        if round(new_price) - new_price < 0.0001:
            discount_odd.append(round(new_price))
        else:
            discount_odd.append(int(new_price))
    else:
        discount_odd.append(data_odd[i])
ans1 = sum(discount_even) + sum(discount_odd)
ans2 = abs((sum(data_even) - sum(discount_even)) - (sum(data_odd) - sum(discount_odd)))
print(ans1, ans2)  # 4151899 464997

# 19890
f = open('files/26.3_19890.txt')
n, m = map(int, f.readline().split())
sp = []

for i in f:
    sp.append(int(i))

sp.sort()

for i in range(310, 321):
    if i in sp:
        ny = sp.index(i)
        break

cy = 0
my = 0
cp = 0

for i in range(ny, len(sp)):
    if my + sp[i] <= m and sp[i] <= 320:
        my += sp[i]
        cy += 1
        cp = sp[i]
    if m - my <= 0 or sp[ny] > 320:
        break

for i in range(ny):
    if my + sp[i] <= m:
        my += sp[i]
        cy += 1
        cp = sp[i]
    else:
        break

if (m - my + cp) in sp:
    my += m - my

print(cy, my)

# 26 №19599
from math import ceil
f = open('files/26_19599.txt')
n = int(f.readline())
data = []
for s in f:
    data.append(list(map(int, list(s.split()))))
for x in data:
    x[0] = x[0] - 1
    for j in range(2, 6):
        x[j] = x[j] - 1
data.sort()

# n power support opponets(3)
for i in range(n):
    if data[i][1] != 0:
        if data[data[i][2]][1] != 0:
            data[data[i][2]][1] += data[i][1]
        for j in range(3, 6):
            if data[data[i][j]][1] != 0:
                if data[i][1] > data[data[i][j]][1]:
                    data[data[i][j]][1] = 0
                    data[i][1] = ceil(data[i][1] - data[i][1] * 1/3)
                if data[i][1] == data[data[i][j]][1]:
                    data[i][1] = data[data[i][j]][1] = 0
                    break
                if data[i][1] < data[data[i][j]][1]:
                    data[i][1] = 0
                    data[data[i][j]][1] = ceil(data[data[i][j]][1] - data[data[i][j]][1] * 1/3)
                    break
            else:
                pass
c_killed = sum(1 for x in data if x[1] == 0)
max_p = max(x[1] for x in data if x[1] != 0)
print(c_killed, max_p)  # 4228 5962

# 26_горбачев5

f = open('files/26_горбачев5.txt')
N, M, K = map(int, f.readline().split())
mx = 0
s = [M + 1] * (K + 1)

for i in f:
    r, m = map(int, i.split())
    s[m] = min(s[m], r)

for i in range(1, K - 3):
    x = min(s[i], s[i + 1], s[i + 2], s[i + 3])
    mx = max(mx, x)

print(mx - 1)

for i in range(1, K - 3):
    if min(s[i], s[i + 1], s[i + 2], s[i + 3]) == mx:
        print(i, i+1, i+2, i+3)
# 9717 5198

# 26 шастин10
"""(Д. Бахтиев) На складе есть К стеллажей для хранения грузов. Все стеллажи пронумерованы, начиная с
единицы. Каждый стеллаж представляет собой двумерную сетку размером М х N, где М — количество
рядов, а N — количество полок в каждом ряду. Каждая ячейка стеллажа может хранить только один груз.
Известно время, в которое каждый груз поступит на склад, и время, до которого его нужно хранить. При
поступлении груза его необходимо разместить в свободную ячейку стеллажа с наименьшим номером,
начиная с первого ряда и первой полки. Если в текущем стеллаже свободных ячеек нет, груз размещается
в следующем стеллаже с наименьшим номером. для размещения или извлечения груза из ячейки
требуется 1 минута. Со следующей минуты ячейка становится доступной для нового груза.
Если груз поступил, но свободных ячеек на всех стеллажах нет
— он не может быть размещён и
отправляется на другой склад.
Если одновременно на склад поступило несколько грузов, то они обслуживаются в порядке возрастания
времени завершения хранения.
Определите, сколько всего грузов будет размещено на складе за 24 часа, и номер ряда первого стеллажа,
на котором побывало наименьшее количество грузов. Если таких рядов несколько, укажите номер
наименьшего из них."""
f = open('files/26_шастин10.txt')
k, m, n = map(int, f.readline().split())
g = int(f.readline())
data = sorted([list(map(int, f.readline().split())) for _ in range(g)])
storage = [[[-1] * n for _ in range(m)] for _ in range(k)]
statist = [[0] * m for _ in range(k)]
for st, en in data:
    status = 1
    for shelf in range(k):
        for row in range(m):
            for place in range(n):
                if status and storage[shelf][row][place] < st:
                    storage[shelf][row][place] = en
                    statist[shelf][row] += 1
                    status = 0

print(sum([sum(row) for row in statist]), statist[0].index(min(statist[0])) + 1)  # 8380 18

"""№ 20910 Апробация 05.03.25 (Уровень: Средний)
При онлайн-покупке билета на концерт известно, какие места в зале уже заняты.
Необходимо купить два билета на такие соседние места в одном ряду,
чтобы перед ними все кресла с такими же номерами были свободны, а ряд находился как можно дальше от сцены.
Если в этом ряду таких пар мест несколько, найдите пару с наименьшими номерами.
В ответе запишите два целых числа: искомый номер ряда и наименьший номер места в найденной паре.
Нумерация рядов и мест ведётся с 1. Гарантируется, что хотя бы одна такая пара в зале есть.
Входные данные
В первой строке входного файла находятся три числа: N – количество занятых мест в зале (целое положительное число,
не превышающее 10 000), M – количество рядов (целое положительное число, не превышающее 100 000) и
K – количество мест в каждом ряду (целое положительное число, не превышающее 100 000).
В следующих N строках находятся пары натуральных чисел: номер ряда и номер места занятого кресла соответственно
(первое число не превышает значения M, а второе – K).
Выходные данные
Два целых положительных числа: наибольший номер ряда и наименьший номер места в найденной паре кресел.
Типовой пример организации данных во входном файле
n m k
7 7 8
1 1
6 6
5 5
6 7
4 4
2 2
3 3
При таких исходных данных ответом является пара чисел 5 и 6. Условию задачи удовлетворяют места 6 и 7 в ряду 5:
перед креслами 6 и 7 нет занятых мест и это первая из двух возможных пар в этом ряду.
В рядах 6 и 7 искомую пару найти нельзя."""

# SS
# Очень Долго
f = open('files/26_20910.txt')
n, m, k = map(int, f.readline().split())
data = sorted([list(map(int, x.split())) for x in f])
for i in range(len(data)):
    data[i][0] -= 1
    data[i][1] -= 1
hall = [[0 for _ in range(k)] for _ in range(m)]
for riad, place in data:
    hall[riad][place] = 1
places = [0 for _ in range(k)]
ans = [[0, 0], [0, 0]]
for i in range(m):
    for j in range(k-1):
        if places[j] + places[j+1] == 0 and hall[i][j] + hall[i][j+1] == 0:
            ans[0] = [i+1, j+1]
            ans[1] = [i+1, j+2]
            break
    for j in range(k):
        if hall[i][j] == 1:
            places[j] += 1
print(ans)

# Кабанов
f = open('files/26_20910.txt')
N, M, K = [int(x) for x in f.readline().split()]
print(N, M, K)
min_ryad = [M + 1] * (K + 1)
for s in f:
    ryad, mesto = [int(x) for x in s.split()]
    min_ryad[mesto] = min(min_ryad[mesto], ryad)
m = []
for mesto in range(1, K):
    r = min(min_ryad[mesto], min_ryad[mesto + 1]) - 1
    if r == 21028:
        print(mesto, mesto + 1)  # 6660 6661
    m.append(r)
print(m)
print(max(m))  # 21028

# 26_горбачев6
"""Система отслеживания безбилетников ежеминутно фиксирует вход и выход пассажиров
электрички (в минутах, прошедших от начала суток). Считается, что в моменты фиксации
входа и выхода пассажир находится в электричке. Нулевая минута соответствует моменту
открытия дверей на первой станции поезда, который катается целые сутки без перерыва.
Аналитик транспортной компании проверяет данные системы наблюдения за прошедшие
сутки, и выявляет момент времени, в которые число пассажиров, находящихся в поезде,
было максимальным. Назовём такой момент времени часом пик.
Входной файл содержит время входа и выхода каждого пассажира электрички. Определите
число пассажиров в час пик и момент времени, когда начался час пик.
Входные данные
В первой строке входного файла находится натуральное число N (N < 10000) - общее
количество пассажиров поезда.
Следующие N строк содержат пары чисел, обозначающих соответственно время входа и
время выхода пассажира (все числа натуральные, не превышающие 1440).
Запишите в ответе два натуральных числа: сначала найденное количество пассажиров в
час пик, затем минуту начала часа пик."""
f = open('files/26_горбачев6.txt')
# f = open('files/26_горбачев6_exaple.txt')
n = int(f.readline())
enter = []
exit = []
pas = []
for i in range(n):
    x, y = map(int, f.readline().split())
    enter.append(x)
    exit.append(y)
mx = 0
k = 0
for i in range(0, 1440):
    if i in enter:
        k += enter.count(i)
    if i in exit:
        k -= exit.count(i)
    mx = max(mx, k)
    if k == 445:
        print(i)
    pas.append([i, k])

print(mx)
print(pas)
# 445, 1057

# №9756
"""№ 9756 Основная волна 19.06.23 (Уровень: Средний)
Входной файл содержит сведения о заявках на проведение занятий в конференц-зале. 
В каждой заявке указаны время начала и время окончания мероприятия (в минутах от начала суток). 
Если время начала одного мероприятия меньше времени окончания другого, то провести можно только одно из них. 
Если время окончания одного мероприятия совпадает с временем начала другого, то провести можно оба. 
Определите максимальное количество мероприятий, которое можно провести в конференц-зале и самое позднее время
окончания последнего мероприятия.
Входные данные
В первой строке входного файла находится натуральное число N (N ≤ 1000) – количество заявок на проведение мероприятий. 
Следующие N строк содержат пары чисел, обозначающих время начала и время окончания мероприятий. 
Каждое из чисел натуральное, не превосходящее 1440.
Запишите в ответе два числа: максимальное количество мероприятий, 
которое можно провести в конференц-зале и 
самое позднее время окончания последнего мероприятия (в минутах от начала суток)."""

# Открываем файл с данными
# f = open('files/26_9756.txt')
f = open('files/26_9756_example.txt')

# Считываем количество заявок
n = int(f.readline())

# Создаем пустой список для хранения данных о мероприятиях
data = []

# Инициализируем счетчик мероприятий и время окончания последнего выбранного мероприятия
c, last = 0, 0

# Считываем данные о каждом мероприятии и добавляем их в список
for _ in range(n):
    st, end = map(int, f.readline().split())
    data.append([st, end])

# Сортируем мероприятия по времени окончания
data.sort(key=lambda x: x[1])

# Список для хранения выбранных мероприятий
ans = []

# Проходим по отсортированному списку мероприятий
for i in range(len(data)):
    # Если текущее мероприятие начинается после или в момент окончания последнего выбранного мероприятия
    if data[i][0] >= last:
        # Увеличиваем счетчик мероприятий
        c += 1
        # Обновляем время окончания последнего выбранного мероприятия
        last = data[i][1]
        # Добавляем текущее мероприятие в список выбранных
        ans.append(data[i])

# Инициализируем переменную для хранения самого позднего времени окончания
ans2 = 0

# Проходим по всем мероприятиям
for i in range(n):
    # Если мероприятие начинается после окончания предпоследнего выбранного мероприятия
    # и заканчивается позже последнего выбранного мероприятия
    if data[i][0] >= ans[-2][1] and data[i][1] > ans[-1][1]:
        # Обновляем самое позднее время окончания
        ans2 = data[i][1]

# Выводим максимальное количество мероприятий и самое позднее время окончания
print(c, ans2)  # 16 1345

# 9793
"""№ 9793 Основная волна 20.06.23 (Уровень: Средний)
На производстве штучных изделий N деталей должны быть отшлифованы и окрашены. Для каждой детали известно время
её шлифовки и время окрашивания. Детали пронумерованы начиная с единицы. 
Параллельная обработка деталей не предусмотрена.
На ленте транспортёра имеется N мест для каждой из N деталей.
На ленте транспортёра детали располагают по следующему алгоритму:
— все 2N чисел, обозначающих время окрашивания и шлифовки для N деталей, упорядочивают по возрастанию;
— если минимальное число в этом упорядоченном списке — это время шлифовки конкретной детали, 
то деталь размещают на ленте транспортёра на первое свободное место от её начала;
— если минимальное число — это время окрашивания, 
то деталь размещают на первое свободное место от конца ленты транспортёра
— если число обозначает время окрашивания или шлифовки уже рассмотренной детали, то его не принимают во внимание.
Этот алгоритм применяется последовательно для размещения всех N деталей.
Определите номер последней детали, для которой будет определено её место на ленте транспортёра, и количество деталей, 
которые будут отшлифованы до неё."""

f = open('files/26_9793.txt')
# f = open('files/26_9793_example.txt')
n = int(f.readline())
data = []
for i in range(n):
    shlif, okr = map(int, f.readline().split())
    if shlif < okr:
        data.append([shlif, 'shlif', i + 1])
    else:
        data.append([okr, 'okr', i + 1])

data.sort()
data_shlif = [x for x in data if x[1] == 'shlif']
print(data_shlif[-1][2], len(data_shlif) - 1)  # 895 488

# 9847
"""№ 9847 Основная волна 27.06.23 (Уровень: Сложный)

Система наблюдения ежеминутно фиксирует вход и выход посетителей магазина (в минутах, прошедших от начала суток). 
Считается, что в моменты фиксации входа и выхода посетитель находится в магазине. 
Нулевая минута соответствует моменту открытия магазина, который работает 24 ч в сутки без перерыва. 
Менеджер магазина анализирует данные системы наблюдения за прошедшие сутки, и выявляет отрезки времени наибольшей длины, 
в течение которых число посетителей, находящихся в магазине, не изменялось. 
Далее менеджер выбирает пики посещаемости — промежутки времени, когда количество посетителей в магазине было наибольшим. 
Пиков посещаемости в течение суток может быть несколько.
Входной файл содержит время входа и выхода каждого посетителя магазина. 
Определите, сколько пиков посещаемости было в течение суток, и укажите число посетителей в момент пика посещаемости.
Входные данные
В первой строке входного файла находится натуральное число N (N < 10000) - количество посетителей магазина.
Следующие N строк содержат пары чисел, обозначающих соответственно время входа и время выхода посетителя 
(все числа натуральные, не превышающие 1440).
Запишите в ответе два натуральных числа: сначала найденное количество пиков посещаемости, 
а затем число посетителей в момент пика посещаемости."""

f = open('files/26_9847.txt')
# f = open('files/26_9847_example.txt')
n = int(f.readline())
enter = []
out = []
for _ in range(n):
    x, y = map(int, f.readline().split())
    enter.append(x)
    out.append(y)

k = 0
time = [0] * 1441
timing = []
for i in range(1441):
    if i in enter:
        k += enter.count(i)
    if k == 643:
        timing.append(i)
    if i in out:
        k -= out.count(i)
    time[i] = k

mx = max(time)
timing_c = 0
for i in range(1, 1441):
    if time[i] == mx and time[i - 1] != mx:
        timing_c += 1

print(timing_c, mx)  # 2 643

f = open('files/26_9847.txt')
N = 100000
M = 1441
visitors = [[] for i in range(N)]
countOfVisitors = [0] * M
n = int(f.readline())
for i in range(n):
    visitors[i] = list(map(int, f.readline().split()))
    for x in range(visitors[i][0], visitors[i][1]):
        countOfVisitors[x] += 1
mx = max(countOfVisitors)
ans1 = 0
for i in range(1, M):
    if (countOfVisitors[i] == mx and countOfVisitors[i - 1] != mx):
        ans1 += 1
print(ans1, mx)  # 2 643

# 17537
"""№ 17537 Основная волна 07.06.24 (Уровень: Средний)

При онлайн-покупке билета на концерт известно, какие места в зале уже заняты. 
Необходимо купить два билета на такие соседние места
в одном ряду, чтобы перед ними все кресла с такими же номерами были свободны, 
а ряд находился как можно дальше от сцены. 
Если в этом ряду таких пар мест несколько, найдите пару с наибольшими номерами. 
В ответе запишите два целых числа: искомый номер ряда и наибольший номер места в найденной паре. 
Нумерация рядов и мест ведётся с 1. Гарантируется, что хотя бы одна такая пара в зале есть.
Входные данные
В первой строке входного файла находятся три числа: 
N — количество занятых мест в зале (целое положительное число, не превышающее 10000), 
М — количество рядов (целое положительное число, не превышающее 100 000) и 
К — количество, мест в каждом ряду (целое положительное число, не превышающее 100 000). 
В следующих N строках находятся пары натуральных чисел: 
номер ряда и номер места занятого кресла соответственно (первое число не превышает значения М, а второе — К)."""
# Открываем файл с данными
f = open('files/26_17537.txt')
# f = open('files/26_17537_example.txt')

# Считываем количество занятых мест, количество рядов и количество мест в каждом ряду
n, m, k = map(int, f.readline().split())

# Создаем список для хранения минимального номера ряда, в котором занято место с данным номером
# Инициализируем его значением, превышающим количество рядов
min_ryad = [m + 1] * (k + 1)

# Обновляем список min_ryad для каждого занятого места
for _ in range(n):
    r, m = map(int, f.readline().split())
    min_ryad[m] = min(min_ryad[m], r)

# Инициализируем переменную для хранения максимального свободного ряда
ans1 = 0

# Проходим по всем возможным парам мест
for i in range(1, k):
    # Определяем максимальный ряд, в котором оба места свободны
    ans1 = max(ans1, min(min_ryad[i] - 1, min_ryad[i + 1] - 1))
# Для пары мест (1, 2):
# 
#     min_ryad[1] - 1 = 4 (место 1 свободно в рядах 1-4)
#     min_ryad[2] - 1 = 5 (место 2 свободно в рядах 1-5)
#     min(4, 5) = 4, значит, оба места свободны в ряду 4.

# Выводим максимальный свободный ряд
print(ans1)

# Находим пару мест с наибольшими номерами в найденном ряду
for i in range(1, k):
    if min(min_ryad[i] - 1, min_ryad[i + 1] - 1) == ans1:
        print(i, i + 1)
# 9991 5643

# №21424
f = open('files/26_21424.txt')
n = int(f.readline())
data = sorted(list(map(int, f.readlines())))

boxes = [0]
for i in range(len(data)):
    if data[i] - boxes[-1] >= 9:
        boxes.append(data[i])
print(boxes)  # 1040
print(len(boxes) - 1)
x = 50
boxes1 = boxes[1:]
while len(boxes1) == 1040:
    x += 1
    boxes = [x]
    for i in range(len(data)):
        if data[i] - boxes[-1] >= 9:
            boxes.append(data[i])
    boxes1 = boxes
print(x - 1)  # 57

# Решу Егэ
f = open('files/26_21424.txt')
n = f.readline()
boxes = sorted([int(i) for i in f], reverse=True)
answer = [boxes[0]]
for box in boxes[1:]:
    if answer[-1] - box >= 9:
        answer.append(box)
print(len(answer), answer[-1])  # 1040 57

# shkolkovo 63974
"""В городе планируется музыкальный фестиваль, на который открыт предзаказ билетов. 
Каждая заявка на предзаказ содержит только одно целое число - количество билетов, которые человек хочет купить.
Перед началом фестиваля кассир распределяет заявки следующим образом: в первую очередь рассматриваются заявки, 
содержащие наибольшее количество билетов для покупки. Все билеты из одной заявки должны находится в одном ряду. 
А также, в первую очередь заполняется ряд с наименьшим номером.
Определите, какое количество заявок подтвердит кассир и сколько свободных мест останется после распределения всех заявок.
Входные данные. В первой строке находится три числа: 
A - количество рядов, B - количество мест в ряду и C - количество заявок. 
В каждом из С следующих строк находится одно число - количество билетов в заявке.
Выходные данные. Два числа через пробел - сначала количество подтвержденных заявок, затем количество оставшихся мест."""
with open('files/26_2__1vv2z.txt') as f:
    # k - количество рядов
    # m - количество мест в ряду
    # n - количество заявок
    k, m, n = map(int, f.readline().split())
    # Список заявок
    s = [int(f.readline()) for _ in range(n)]
# Сортируем список так, чтобы в начале стояли наибольшие числа
s.sort(reverse=True)

# Список для обозначения свободных мест
free = [m] * k
# Количество подтверждённых заявок
cnt = 0

# Проходимся по заявкам
for x in s:
    # Проходимся по каждому ряду
    for i in range(k):
        # Если в ряду достаточно свободных мест для заявки — засчитываем
        if free[i] >= x:
            # Отнимаем кол-во занимаемых мест от кол-ва свободных мест в этом ряду
            free[i] -= x
            cnt += 1
            break  # сбрасываем цикл - переходим к следующей заявке
print(cnt, sum(free))

# shkolkovo #106916
"""При онлайн-покупке билета на концерт известно, какие места в зале уже заняты. 
Необходимо купить два билета на такие соседние места в одном ряду, 
чтобы за ними все кресла с такими же номерами были свободны, а ряд находился как можно ближе к сцене. 
Сцена расположена перед первым рядом. Если в этом ряду таких пар мест несколько, 
найдите пару с наименьшими номерами мест. 
Нумерация рядов и мест ведётся с 1. Гарантируется, что хотя бы одна такая пара в зале есть. 
Определите наименьший номер ряда и наименьший номер места для найденной пары мест.
Входные данные представлены в файле следующим образом. В первой строке входного файла находятся три числа: 
N   – количество занятых мест в зале (целое положительное число, не превышающее 10000), 
M   – количество рядов (целое положительное число, не превышающее 100 000) и 
K   – количество, мест в каждом ряду (целое положительное число, не превышающее 100 000). 
В следующих N   строках находятся пары натуральных чисел: 
номер ряда и номер места занятого кресла соответственно (первое число не превышает значения M  , а второе – K  )."""

f = open('files/task26__5z1ta.txt')
n, m, k = map(int, f.readline().split())
mx_ryad = [0] * (k + 1)

for s in f:
    ryad, mesto = map(int, s.split())
    mx_ryad[mesto] = max(mx_ryad[mesto], ryad)

ans = [m + 1, 0]
for i in range(len(mx_ryad) - 1):
    ans[0] = min(ans[0], max(mx_ryad[i] + 1, mx_ryad[i + 1] + 1))

for i in range(len(mx_ryad) - 1):
    if max(mx_ryad[i] + 1, mx_ryad[i + 1] + 1) == 627:
        ans[1] = i
print(ans)  # [627, 503]

# №21598
"""№ 21598 (Уровень: Средний)
Система наблюдения ежеминутно фиксирует вход и выход сотрудников из офиса (в минутах, прошедших от начала суток). 
Считается, что в моменты фиксации входа и выхода сотрудник находится в офисе. 
Нулевая минута соответствует моменту начала рабочего дня в офисе, который длится 24 ч в сутки без перерыва.
Менеджер компании анализирует данные системы наблюдения за прошедшие сутки, 
и выявляет непересекающиеся отрезки времени наибольшей длины, в течение которых число сотрудников, 
находящихся в офисе, не изменялось.
Входной файл содержит время входа и выхода каждого сотрудника компании. 
Определите минуту, когда в предпоследний раз за сутки число сотрудников поменялось, 
и укажите наибольшую длину отрезка времени, когда количество сотрудников оставалось неизменным.
Входные данные
В первой строке входного файла находится натуральное число N (N ≤ 100 000) – количество сотрудников компании. 
Следующие N строк содержат пары чисел, обозначающих соответственно время входа и время выхода сотрудника 
(все числа натуральные, не превышающие 1440).
Запишите в ответе два натуральных числа: сначала минуту, 
когда в предпоследний раз за сутки число сотрудников поменялось, а затем
наибольшую длительность промежутка времени, при котором количество сотрудников оставалось неизменным."""
f = open('files/26_21598.txt')
# f = open('files/test.txt')
n = map(int, f.readline())
inside = []
outside = []
for s in f:
    x, y = map(int, s.split())
    inside.append(x)
    outside.append(y)

c = 0
time = [0] * 1440
dlin = [[0]]
for i in range(len(time) - 1):
    if i in inside:
        c += 1
        time[i] = c
    if i in outside:
        c -= 1
        time[i] = c
    if time[i] != time[i + 1]:
        dlin[-1].append(i)
        dlin.append([i])
if len(dlin[-1]) == 1:
    dlin[-1].append(1440)
mx_dlin = max(y - x for x, y in dlin)
print(dlin[-2][0], mx_dlin)  # 1431

# ЕГКР 19.04 В1
f = open('files/26_егкр19.04_1.txt')
# f = open('files/26_егкр19.04_test.txt')
n = int(f.readline())
data = list(list(map(int, s.split())) for s in f)
data.sort()
st = [[[0, 0]]]
for i in range(len(data) - 1):
    if data[i][0] == data[i + 1][0]:
        if data[i][0] != st[-1][0][0]:
            st.append([data[i]])
        if data[i + 1][1] - st[-1][-1][1] == 2:
            st[-1].append(data[i + 1])

ln = [len(x) for x in st]
print(st)
print(ln)
mx = [[x[0][0], len(x)] for x in st]
print(mx)
ans = max(mx, key=lambda x: x[1])
print(ans)  # 10031 26

# ЕГКР 19.04 В2
f = open('files/26_егкр19.04_2.txt')
# f = open('files/26_егкр19.04_test.txt')
n = int(f.readline())
data = list(list(map(int, s.split())) for s in f)
data.sort()
st = [[[0, 0]]]
for i in range(len(data) - 1):
    if data[i][0] == data[i + 1][0]:
        if data[i][0] != st[-1][0][0]:
            st.append([data[i]])
        if data[i + 1][1] - st[-1][-1][1] == 2:
            st[-1].append(data[i + 1])

ln = [len(x) for x in st]
# print(st)
print(max(st, key=len))
# print(ln)
mx = [[x[0][0], len(x)] for x in st]
# print(mx)
ans = max(mx, key=lambda x: x[1])
print(ans)  # 10135 42

"""№ 21570 Чернобыльский вариант 2025
(М. Попков) В машинном зале реакторного блока РБМК находится 25 насосов,
обеспечивающих циркуляцию охлаждающей жидкости через активную зону.
В течение суток поступают заявки на включение насосов —
каждая заявка представляет собой команду
на подачу охлаждающего потока в конкретный момент времени.
В заявке указано время начала подачи и длительность работы насосного блока.
Если в момент начала подачи есть свободный насос, заявка выполняется,
и насос начинает работать на указанный интервал времени.
Если в этот момент все насосы уже заняты, система охлаждения не справляется,
и заявка получает отказ. Если одна заявка заканчивается в тот же момент,
когда начинается другая, освободившийся насос может быть сразу же задействован новой заявкой.
Входные данные
Первая строка входного файла содержит целое число N (N ≤ 2000) — общее количество заявок.
Каждая из следующих N строк описывает одну заявку и содержит два целых числа:
время начала подачи охлаждения T (в минутах от начала суток) и длительность подачи L (в минутах).
Гарантируется, что все заявки укладываются в границы суток:
0 ≤ T < T + L ≤ 1440, и что моменты времени T уникальны.
Определите, сколько заявок останутся невыполненными из-за отсутствия свободных насосов,
и какова будет суммарная длительность времени (в минутах),
в течение которого в работе находилось менее 13 насосов.
В ответе запишите два целых числа: сначала количество отказов,
затем — длительность периода низкой мощности охлаждения."""

f = open('files/26_21570.txt')
n = int(f.readline())
k = 25
a = []
for line in f:
    T1, L = map(int, line.split())
    T2 = T1 + L
    a.append([T1, T2])
a.sort()

pumps = [[0] * 1440 for i in range(25)]
cnt_no = 0
for start, end in a:
    for i in range(k):
        if sum(pumps[i][start:end]) == 0:
            for m in range(start, end):
                pumps[i][m] = 1
            break
    else:
        cnt_no += 1

cnt_m = 0
for m in range(0, 1440):
    cnt_pumps = 0
    for i in range(k):
        if pumps[i][m] == 1:
            cnt_pumps += 1
    if cnt_pumps < 13:
        cnt_m += 1

print(cnt_no, cnt_m)  # 488 19

# 26 №21588
"""№ 21588 (Уровень: Сложный)
(Л. Шастин) Группа авантюристов хочет добраться до максимально возможно отдаленной от экватора зоны Земли, 
для чего им предстоит пересечь множество других зон в качестве перевалочных пунктов. 
При посещении очередной зоны авантюристы затрачивают некоторую сумму денежных единиц на организацию перевала, 
эта сумма может варьироваться в зависимости от отправной и конечной зоны. 
Начинает свой путь группа в зоне №1, а изначальные затраты средств равны нулю. Известно, 
что чем больше номер зоны, тем дальше она расположена от экватора. 
Из каждой зоны можно попасть только в щоны с большим номером. 
Имеется NN записей, каждая из которых содержит информацию о какой-то зоне: 
номер текущей зоны, номер переходной зоны, 
до которой можно добраться отсюда и сумма средств для посещения переходной зоны. 
Каждая зона может быть представлена в нескольких вариантах с разными переходными пунктами и ценами за переход. 
Некоторые записи также могут содержать информацию о недостижимых зонах 
(в которые невозможно попасть, начав движение из зоны №1). 
Определите номер максимальной зоны, которой могут достигнуть авантюристы, 
если их бюджет составляет KK денежных единиц, а также максимальный возможный остаток средств при этих условиях. 
Входные данные
В первой строке входного файла находится два натуральных числа: 
N (N≤100000)N (N≤100000) – количество записей о зонах и K(K≤1000000)K(K≤1000000) - бюджет, которым располагает группа. 
В каждой из следующих NN строк находятся по три числа: номер текущей зоны, 
номер переходной зоны (в которую можно передвинуться из текущей) и сумма средств, 
необходимая для перехода. Каждое из чисел натуральное, не превосходящее 10000001000000. 
Запишите в ответе два числа: номер максимальной зоны, которой могут достигнуть авантюристы, 
если их бюджет составляет K K денежных единиц, а также максимальный возможный остаток средств при этих условиях."""

f = open('files/26_21588.txt')

N, K = [int(x) for x in f.readline().split()]

a = []
for s in f:
    fr, to, s = [int(x) for x in s.split()]
    a.append([to, fr, s])

a.sort()

d = {1: 0}

for to, fr, s in a:
    if fr in d and d[fr] + s <= K:
        if to not in d:
            d[to] = d[fr] + s
        else:
            d[to] = min(d[to], d[fr] + s)

m = max(d.keys())
print(m, K - d[m])  # 4835 419

"""№ 20970 (Уровень: Средний)
(М. Попков) В сервисном центре работают K мастерских для ремонта устройств.
Некоторые поломки могут быть устранены только в определённой мастерской, некоторые – в любой мастерской.
Устройство поступает в центр и ставится в очередь к той мастерской, которая может устранить его проблему.
Если поломка может быть устранена в любой мастерской, устройство направляется в ту,
в очереди к которой в данный момент меньше единиц техники.
Если при этом очереди в несколько мастерских одинаковые, устройство отправляется в мастерскую с наименьшим номером.
При этом, если в очереди к выбранной мастерской уже находится 5 или более устройств
(включая устройство, которое ремонтируют в данный момент), поступившее устройство сразу отправляют на утилизацию.
Если момент завершения ремонта одного или нескольких устройств совпадает с моментом поступления нового устройства,
то можно считать, что новое устройство поступило после того,
как ремонт ранее поступивших устройств завершился и очередь сократилась.
Входные данные
Первая строка входного файла содержит два целых числа:
N (N ≤ 1000) – общее количество устройств,
поступивших в сервисный центр за один рабочий день, и K (K ≤ 20) – количество мастерских.
Каждая из следующих N строк описывает одно устройство и содержит 3 целых числа:
время поступления устройства в центр (количество минут с начала рабочего дня), время,
необходимое для ремонта и номер мастерской, в которую его необходимо направить
(0 означает, что ремонт возможен в любой мастерской).
Гарантируется, что никакие два устройства не поступают одновременно.
Определите, наибольшее количество устройств, отремонтированных в течении дня в одной мастерской,
и количество устройств, которые отправятся на утилизацию из-за слишком больших очередей.
В ответе запишите два целых числа: сначала наибольшее количество устройств,
отремонтированных в одной мастерской, затем количество утилизированных устройств."""

f = open('files/26_20970.txt')
n, k = map(int, f.readline().split())
a = []
for line in f:
    start, dlit, mas = map(int, line.split())
    a.append([start, dlit, mas])

a.sort()
cnt_mas = [0] * k
cnt_util = 0
ocheredi = [[] for i in range(k)]
for start, dlit, mas in a:
    for i in range(k):
        while ocheredi[i] != [] and ocheredi[i][0] <= start:
            del ocheredi[i][0]
    if mas != 0:
        ind_mas = mas - 1
    else:
        ind_mas = 0
        min_len = float('inf')
        for i in range(k):
            if len(ocheredi[i]) < min_len:
                min_len = len(ocheredi[i])
                ind_mas = i
    if ocheredi[ind_mas] == []:
        ocheredi[ind_mas].append(start + dlit)
        cnt_mas[ind_mas] += 1
    elif len(ocheredi[ind_mas]) < 5:
        ocheredi[ind_mas].append(ocheredi[ind_mas][-1] + dlit)
        cnt_mas[ind_mas] += 1
    else:
        cnt_util += 1
print(max(cnt_mas), cnt_util)  # 72 218

# 26 Горбачев7
f = open('files/26_горбачев7.txt')
k = int(f.readline())
n = int(f.readline())
data = sorted(list(list(map(int, s.split())) for s in f))
# example
# k = 2
# n = 5
# data = [[30, 60], [40, 1110], [59, 60], [61, 120], [1230, 1440]]

camera = [-1 for _ in range(k)]
ans = [0, 0]
for st, end in data:
    for i in range(k-1, -1, -1):
        if camera[i] + 1 <= st:
            camera[i] = end
            ans[1] = i + 1
            break
    else:
        ans[0] += 1
print(ans[0], ans[1])  # 419 152

# 26 Шастин11
"""Задание 26.
(Л. Шастин) Частная клиника работает круглосуточно, в режиме 24/7. 
В течение суток в клинике проводятся медицинские приёмы, 
каждый из которых характеризуется временем начала и окончания (в миллисекундах, прошедших с начала суток). 
Считается, что в миллисекунды начала и конца приема он ещё идет. 
Необходимо проанализировать загруженность врачей за сутки и определить периоды простоя, 
то есть такие отрезки времени, когда ни один приём не проходил.
Входной файл содержит время начала и конца каждого приема (в мс) в течение суток. 
Определите, сколько периодов простоя было в течение суток, и укажите их суммарную Длительность (в мс).
Входные данные
В первой строке входного файла находится натуральное число N (N< 100 000) количество приемов, проведенных за сутки.
Следующие и строк содержат пары чисел, 
обозначающих соответственно время начала и время конца приёма (все числа натуральные, меньшие 86400000).
Запишите в ответе два натуральных числа: сначала найденное количество периодов простоя, 
а затем их суммарную длительность (в мс).
Типовой пример организации данных во входном файле
6
10 50
100 150
110 155
120 160
130 170
151 170
При таких исходных данных и длительности работы клиники в 200 мс было три периода простоя: 
в отрезки времени с 0 по 9 мс, с 51 по 99 мс и с 171 по 199 мс. 
Их суммарная длительность равна (10 - 0) + (100 - 51) + (200 - 171) = 88. Ответ для примера: 3 88.
Типовой пример имеет иллюстративный характер. Для выполнения задания используйте Данные из прилагаемых файлов."""

f = open('files/26_шастин11.txt')
n = int(f.readline())
d = 86400000  # длительность суток в мс
data = sorted([list(map(int, s.split())) for s in f])
# example
n = 6
d = 200
data = [[10, 50], [100, 150], [110, 155], [120, 160], [130, 170], [151, 170]]

intervals = []
current_start = 0  # начало первого возможного простоя

for st, end in data:
    if st > current_start:
        # Найден период простоя от current_start до st-1
        intervals.append((current_start, st - 1))
    current_start = max(current_start, end + 1)  # следующий возможный простой начинается после конца текущего приёма

# Проверяем последний период простоя (если есть)
if current_start < d:
    intervals.append((current_start, d - 1))

# Подсчёт результатов
ans1 = len(intervals)
ans2 = sum(end - start + 1 for start, end in intervals)  # +1 потому что обе границы включены

print(intervals)
print(ans1, ans2)  # 36 35834